<style>
.waypoint-placeholder {
  background: #ffeb3b !important;
  border: 2px dashed #ff9800 !important;
  height: 30px !important;
  margin: 2px 0 !important;
}
</style>

<script type="text/javascript">
  // Event management utilities
  const TaskV2EventUtils = {
    currentNode: null, // Store reference to current node
    
    setCurrentNode: function(node) {
      this.currentNode = node;
    },
    
    addEvent: function(container, eventData = {}) {
      const eventId = Date.now() + Math.random();
      const eventDiv = $(`
        <div class="event-item" data-event-id="${eventId}" style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; background: #f9f9f9;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <label style="font-weight: bold;">Event ${container.children().length + 1}</label>
            <button type="button" class="remove-event red-ui-button" style="background: #d32f2f;">
              <i class="fa fa-trash"></i> Remove
            </button>
          </div>
          
          <div class="form-row">
            <label>Event Type:</label>
            <select class="event-category" style="width: 100%;">
              <option value="go_to_place">Go To Place</option>
              <option value="go_to_zone">Go To Zone</option>
              <option value="perform_action">Perform Action</option>
            </select>
          </div>
          
          <div class="event-details">
            <!-- Event-specific fields will be inserted here -->
          </div>
        </div>
      `);
      
      container.append(eventDiv);
      
      // Set up event handlers
      eventDiv.find('.remove-event').on('click', function() {
        eventDiv.remove();
        TaskV2EventUtils.updateEventLabels(container);
      });
      
      eventDiv.find('.event-category').on('change', function() {
        TaskV2EventUtils.updateEventDetails(eventDiv, $(this).val());
      }).val(eventData.category || 'go_to_place');
      
      // Initialize event details
      TaskV2EventUtils.updateEventDetails(eventDiv, eventData.category || 'go_to_place', eventData);
      
      // If we have eventData, restore values after dropdown population
      if (eventData && Object.keys(eventData).length > 1) {
        setTimeout(() => {
          TaskV2EventUtils.restoreEventValues(eventDiv.parent(), [eventData]);
        }, 50);
      }
      
      return eventDiv;
    },
    
    updateEventLabels: function(container) {
      container.find('.event-item').each(function(index) {
        $(this).find('label').first().text(`Event ${index + 1}`);
      });
    },
    
    updateEventDetails: function(eventDiv, category, eventData = {}) {
      const detailsDiv = eventDiv.find('.event-details');
      detailsDiv.empty();
      
      if (category === 'go_to_place') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Location</label>
            <select class="event-location" style="width: 100%;">
              <option value="">Select waypoint...</option>
            </select>
          </div>
          <div class="form-row">
            <label>Orientation (radians)</label>
            <input type="number" class="event-orientation" min="-6.28" max="6.28" step="0.001" style="width: 100%;" placeholder="Optional: Final facing angle in radians">
            <div class="form-tips">Set the final facing direction (in radians) when the robot reaches the waypoint. Leave empty to use default facing.</div>
          </div>
        `);
        
        // Populate waypoints from RMF navGraphs data (waypoints only, no zones)
        const node = TaskV2EventUtils.currentNode;
        if (node && node.rmfData && node.rmfData.navGraphs) {
          console.log('Populating waypoints, navGraphs:', node.rmfData.navGraphs.length);
          const locationSelect = detailsDiv.find('.event-location');
          const waypoints = new Map(); // Use Map to avoid duplicates
          
          // Extract waypoints from nav graphs
          node.rmfData.navGraphs.forEach(navGraph => {
            if (navGraph.vertices) {
              navGraph.vertices.forEach(vertex => {
                if (vertex.name && vertex.name.trim() !== '') {
                  // Check if this vertex is part of a zone (exclude zone vertices)
                  const isPartOfZone = node.rmfData.zones && node.rmfData.zones.some(zone => {
                    const zoneVertices = getZoneVertices(zone);
                    if (zoneVertices.length === 0) return false;
                    return zoneVertices.some(zv => {
                      if (zv.name && zv.name === vertex.name) return true;
                      if (typeof zv === 'number' && vertex.index === zv) return true;
                      if (zv.x !== undefined && zv.y !== undefined && 
                          Math.abs(zv.x - vertex.x) < 0.01 && Math.abs(zv.y - vertex.y) < 0.01) {
                        return true;
                      }
                      return false;
                    });
                  });
                  
                  // Only add if it's not part of a zone
                  if (!isPartOfZone) {
                    waypoints.set(vertex.name, {
                      name: vertex.name,
                      fleet: navGraph.fleet || navGraph.name
                    });
                  }
                }
              });
            }
          });
          
          console.log('Found waypoints:', waypoints.size);
          
          // Populate dropdown with sorted waypoints
          Array.from(waypoints.values()).sort((a, b) => a.name.localeCompare(b.name)).forEach(waypoint => {
            locationSelect.append(`<option value="${waypoint.name}">${waypoint.name}</option>`);
          });
          
          // Set saved value if provided
          if (eventData.description) {
            locationSelect.val(eventData.description);
            console.log('Set waypoint value to:', eventData.description, 'Found in dropdown:', locationSelect.find(`option[value="${eventData.description}"]`).length > 0);
          }
        } else {
          console.log('No RMF data available for waypoints. Node:', !!node, 'rmfData:', node ? !!node.rmfData : 'no node', 'navGraphs:', node && node.rmfData ? node.rmfData.navGraphs?.length : 'no rmfData');
        }
        
      } else if (category === 'go_to_zone') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Zone:</label>
            <select class="event-zone" style="width: 100%;">
              <option value="">Select zone...</option>
            </select>
          </div>
          <div class="form-row">
            <label>Zone Types (optional):</label>
            <select class="event-zone-types" multiple style="width: 100%; height: 80px;">
              <option value="all" selected>All</option>
              <option value="human_facing">Human Facing</option>
              <option value="left">Left</option>
              <option value="right">Right</option>
              <option value="center">Center</option>
              <option value="top">Top</option>
              <option value="bottom">Bottom</option>
            </select>
            <div class="form-tips">Hold Ctrl/Cmd to select multiple zone entry types. 'All' is mutually exclusive with other selections.</div>
          </div>
          <div class="form-row">
            <label>Preferred Places (optional):</label>
            <div class="event-zone-places-container" style="border: 1px solid #ddd; padding: 10px; max-height: 300px; overflow-y: auto;">
              <div class="form-tips" style="margin-bottom: 10px;">Select waypoints from available list. Drag selected waypoints to reorder priority (top = highest priority).</div>
              
              <div style="display: flex; gap: 10px;">
                <!-- Available waypoints -->
                <div style="flex: 1;">
                  <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Available Waypoints</h4>
                  <div class="available-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #fafafa;">
                    <!-- Available waypoints will be populated here -->
                  </div>
                </div>
                
                <!-- Selected waypoints (ordered) -->
                <div style="flex: 1;">
                  <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Selected Waypoints (Priority Order)</h4>
                  <div class="selected-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #f0f8ff;">
                    <!-- Selected waypoints will be shown here in order -->
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="form-row">
            <label>Final Facing (radians, optional):</label>
            <input type="number" class="event-zone-facing" step="0.01" placeholder="e.g., 1.57 (90 degrees) - applies if no waypoint orientations set" style="width: 100%;">
          </div>
        `);
        
        // Populate zones from RMF data
        const node = TaskV2EventUtils.currentNode;
        if (node && node.rmfData && node.rmfData.zones) {
          console.log('Populating zones, zones:', node.rmfData.zones.length);
          const zoneSelect = detailsDiv.find('.event-zone');
          const placesSelect = detailsDiv.find('.event-zone-places');
          
          // Populate zones
          node.rmfData.zones.forEach(zone => {
            if (zone.name && zone.name.trim() !== '') {
              zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
            }
          });
          
          // Handle zone types selection logic
          const zoneTypesSelect = detailsDiv.find('.event-zone-types');
          let previousSelection = ['all']; // Track previous selection
          
          zoneTypesSelect.on('change', function() {
            const selectedValues = $(this).val() || [];
            const allSelected = selectedValues.includes('all');
            const othersSelected = selectedValues.filter(v => v !== 'all');
            
            if (allSelected && othersSelected.length > 0) {
              // Both 'all' and others are selected, determine which was added
              const wasAllPreviouslySelected = previousSelection.includes('all');
              
              if (!wasAllPreviouslySelected) {
                // 'all' was just selected, unselect all others
                $(this).val(['all']);
                previousSelection = ['all'];
              } else {
                // Another option was just selected, unselect 'all'
                $(this).val(othersSelected);
                previousSelection = othersSelected;
              }
            } else if (selectedValues.length === 0) {
              // If nothing is selected, default to 'all'
              $(this).val(['all']);
              previousSelection = ['all'];
            } else {
              // Valid selection, update previous
              previousSelection = selectedValues.slice();
            }
          });
          
          // Update places when zone changes
          zoneSelect.on('change', function() {
            const selectedZone = $(this).val();
            const availableContainer = detailsDiv.find('.available-waypoints');
            const selectedContainer = detailsDiv.find('.selected-waypoints');
            
            availableContainer.empty();
            selectedContainer.empty();
            
            if (selectedZone) {
              const zone = node.rmfData.zones.find(z => z.name === selectedZone);
              if (zone) {
                console.log('Zone data for', selectedZone, ':', zone);
                
                const zoneVertices = getZoneVertices(zone);
                console.log('Zone vertices:', zoneVertices);
                
                if (zoneVertices.length > 0) {
                  zoneVertices.forEach((vertex, index) => {
                    let vertexName, displayName, vertexValue;
                    
                    // Handle different zone vertex structures
                    if (typeof vertex === 'object' && vertex.name) {
                      // Vertex object with name
                      vertexName = vertex.name;
                      vertexValue = vertex.name;
                      displayName = vertexName;
                    } else if (typeof vertex === 'number') {
                      // Vertex index - find corresponding vertex name from navGraphs
                      const graph = node.rmfData.navGraphs ? node.rmfData.navGraphs.find(g => 
                        g.name === zone.graph || g.vertices.length > vertex
                      ) : null;
                      
                      if (graph && graph.vertices[vertex]) {
                        vertexName = graph.vertices[vertex].name || `Vertex ${vertex}`;
                        vertexValue = vertexName;
                        displayName = `${vertexName} (Position ${index + 1})`;
                      } else {
                        vertexName = `Vertex ${vertex}`;
                        vertexValue = `vertex_${vertex}`;
                        displayName = `Position ${index + 1} (Index ${vertex})`;
                      }
                    } else {
                      // Fallback for other structures
                      vertexName = `Position ${index + 1}`;
                      vertexValue = `vertex_${index}`;
                      displayName = vertexName;
                    }
                    
                    // Create available waypoint item
                    const availableItem = $(`
                      <div class="available-waypoint-item" data-waypoint="${vertexValue}" style="
                        padding: 5px; 
                        margin: 2px 0; 
                        background: white; 
                        border: 1px solid #ddd; 
                        cursor: pointer;
                        border-radius: 3px;
                        font-size: 11px;
                      ">
                        <span style="color: #333;">${displayName}</span>
                      </div>
                    `);
                    
                    availableContainer.append(availableItem);
                    
                    // Handle click to add to selected
                    availableItem.on('click', function() {
                      const waypointValue = $(this).data('waypoint');
                      addToSelectedWaypoints(waypointValue, displayName, selectedContainer, availableContainer);
                    });
                  });
                  
                  // Make selected waypoints sortable (fallback if jQuery UI not available)
                  try {
                    selectedContainer.sortable({
                      items: '.selected-waypoint-item',
                      placeholder: 'waypoint-placeholder',
                      tolerance: 'pointer',
                      cursor: 'move'
                    });
                  } catch (e) {
                    console.log('jQuery UI sortable not available, using basic ordering');
                  }
                }
              }
            }
          });
          
          // Function to add waypoint to selected list
          function addToSelectedWaypoints(waypointValue, displayName, selectedContainer, availableContainer) {
            // Check if already selected
            if (selectedContainer.find(`[data-waypoint="${waypointValue}"]`).length > 0) {
              return;
            }
            
            const selectedItem = $(`
              <div class="selected-waypoint-item" data-waypoint="${waypointValue}" style="
                padding: 5px; 
                margin: 2px 0; 
                background: #e3f2fd; 
                border: 1px solid #1976d2; 
                border-radius: 3px;
                font-size: 11px;
                cursor: move;
                display: flex;
                align-items: center;
                gap: 5px;
              ">
                <span class="drag-handle" style="cursor: ns-resize; color: #666; font-weight: bold;">⋮⋮</span>
                <span style="flex: 1; color: #1565c0;">${displayName}</span>
                <input type="number" class="waypoint-orientation" step="0.01" placeholder="orient." style="width: 50px; font-size: 10px;" title="Orientation in radians">
                <button type="button" class="move-up" style="
                  background: #4caf50; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Move up">↑</button>
                <button type="button" class="move-down" style="
                  background: #ff9800; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Move down">↓</button>
                <button type="button" class="remove-waypoint" style="
                  background: #d32f2f; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Remove waypoint">×</button>
              </div>
            `);
            
            selectedContainer.append(selectedItem);
            
            // Hide from available list
            availableContainer.find(`[data-waypoint="${waypointValue}"]`).hide();
            
            // Handle move up button
            selectedItem.find('.move-up').on('click', function(e) {
              e.stopPropagation();
              const prev = selectedItem.prev('.selected-waypoint-item');
              if (prev.length > 0) {
                selectedItem.insertBefore(prev);
              }
            });
            
            // Handle move down button
            selectedItem.find('.move-down').on('click', function(e) {
              e.stopPropagation();
              const next = selectedItem.next('.selected-waypoint-item');
              if (next.length > 0) {
                selectedItem.insertAfter(next);
              }
            });
            
            // Handle remove button
            selectedItem.find('.remove-waypoint').on('click', function(e) {
              e.stopPropagation();
              selectedItem.remove();
              // Show back in available list
              availableContainer.find(`[data-waypoint="${waypointValue}"]`).show();
            });
          }
          
          // Set values from eventData
          if (eventData.zone) {
            zoneSelect.val(eventData.zone);
            zoneSelect.trigger('change'); // Populate places
            console.log('Set zone value to:', eventData.zone, 'Found in dropdown:', zoneSelect.find(`option[value="${eventData.zone}"]`).length > 0);
          }
          if (eventData.types && Array.isArray(eventData.types)) {
            detailsDiv.find('.event-zone-types').val(eventData.types);
          }
          if (eventData.places && Array.isArray(eventData.places)) {
            setTimeout(() => {
              eventData.places.forEach(place => {
                let waypointName, orientation;
                
                if (typeof place === 'string') {
                  waypointName = place;
                  orientation = undefined;
                } else if (place.waypoint) {
                  waypointName = place.waypoint;
                  orientation = place.orientation;
                }
                
                if (waypointName) {
                  const availableContainer = detailsDiv.find('.available-waypoints');
                  const selectedContainer = detailsDiv.find('.selected-waypoints');
                  const availableItem = availableContainer.find(`[data-waypoint="${waypointName}"]`);
                  
                  if (availableItem.length > 0) {
                    // Find the display name from available item
                    const displayName = availableItem.find('span').text();
                    
                    // Add to selected (this will call our function)
                    addToSelectedWaypoints(waypointName, displayName, selectedContainer, availableContainer);
                    
                    // Set orientation if provided
                    if (orientation !== undefined) {
                      const selectedItem = selectedContainer.find(`[data-waypoint="${waypointName}"]`);
                      selectedItem.find('.waypoint-orientation').val(orientation);
                    }
                  }
                }
              });
              console.log('Set zone places from eventData:', eventData.places);
            }, 100);
          }
          if (eventData.facing !== undefined) {
            detailsDiv.find('.event-zone-facing').val(eventData.facing);
          }
        } else {
          console.log('No RMF data available for zones. Node:', !!node, 'rmfData:', node ? !!node.rmfData : 'no node', 'zones:', node && node.rmfData ? node.rmfData.zones?.length : 'no rmfData');
        }
        
      } else if (category === 'perform_action') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Action Category:</label>
            <input type="text" class="event-action-category" value="${eventData.action_category || 'teleop'}" style="width: 100%;">
          </div>
          <div class="form-row">
            <label>Action Description:</label>
            <textarea class="event-action-description" style="width: 100%; height: 60px;">${eventData.action_description || ''}</textarea>
          </div>
          <div class="form-row">
            <label>Duration Estimate (ms):</label>
            <input type="number" class="event-duration-estimate" value="${eventData.duration_estimate || 30000}" style="width: 100%;">
          </div>
        `);
      }
    },
    
    getEventsData: function(container) {
      const events = [];
      container.find('.event-item').each(function() {
        const eventDiv = $(this);
        const category = eventDiv.find('.event-category').val();
        const eventData = { category };
        
        if (category === 'go_to_place') {
          const locationName = eventDiv.find('.event-location').val();
          const orientation = eventDiv.find('.event-orientation').val();
          
          if (orientation && orientation.trim() !== '') {
            // Create place object with orientation
            eventData.description = {
              waypoint: locationName,
              orientation: parseFloat(orientation)
            };
          } else {
            // Simple waypoint name
            eventData.description = locationName;
          }
        } else if (category === 'go_to_zone') {
          eventData.zone = eventDiv.find('.event-zone').val();
          
          // Parse zone types
          const selectedTypes = eventDiv.find('.event-zone-types').val();
          if (selectedTypes && selectedTypes.length > 0) {
            eventData.types = selectedTypes;
          }
          
          // Get selected places with orientations (in order)
          const selectedPlaces = [];
          eventDiv.find('.selected-waypoint-item').each(function() {
            const waypointName = $(this).data('waypoint');
            const orientationInput = $(this).find('.waypoint-orientation');
            const orientation = orientationInput.val();
            
            if (orientation && orientation.trim()) {
              // Create place object with waypoint and orientation
              selectedPlaces.push({
                waypoint: waypointName,
                orientation: parseFloat(orientation)
              });
            } else {
              // Create place object with just waypoint
              selectedPlaces.push({ waypoint: waypointName });
            }
          });
          
          if (selectedPlaces.length > 0) {
            eventData.places = selectedPlaces;
          }
          
          // Get facing direction (fallback for overall zone facing)
          const facing = eventDiv.find('.event-zone-facing').val();
          if (facing && facing.trim()) {
            eventData.facing = parseFloat(facing);
          }
        } else if (category === 'perform_action') {
          eventData.action_category = eventDiv.find('.event-action-category').val();
          eventData.action_description = eventDiv.find('.event-action-description').val();
          eventData.duration_estimate = parseInt(eventDiv.find('.event-duration-estimate').val()) || 30000;
        }
        
        events.push(eventData);
      });
      return events;
    },
    
    setEventsData: function(container, events) {
      console.log('setEventsData called with events:', events);
      container.empty();
      if (events && events.length > 0) {
        events.forEach(eventData => {
          console.log('Adding event:', eventData);
          TaskV2EventUtils.addEvent(container, eventData);
        });
        
        // Delay to ensure dropdowns are populated before setting values
        setTimeout(() => {
          console.log('Restoring event values after delay');
          TaskV2EventUtils.restoreEventValues(container, events);
        }, 100);
      } else {
        // Add default go_to_place event
        TaskV2EventUtils.addEvent(container, { category: 'go_to_place' });
      }
    },
    
    restoreEventValues: function(container, events) {
      // Restore saved values to event dropdowns after they're populated
      console.log('restoreEventValues called with events:', events);
      container.find('.event-item').each(function(index) {
        const eventDiv = $(this);
        const eventData = events[index];
        console.log(`Restoring event ${index}:`, eventData);
        
        if (eventData && eventData.category) {
          // Set category first
          eventDiv.find('.event-category').val(eventData.category);
          
          // Then restore specific values based on category
          if (eventData.category === 'go_to_place' && eventData.description) {
            const locationSelect = eventDiv.find('.event-location');
            const orientationInput = eventDiv.find('.event-orientation');
            
            if (typeof eventData.description === 'string') {
              // Simple waypoint name
              locationSelect.val(eventData.description);
              orientationInput.val('');
            } else if (eventData.description && eventData.description.waypoint) {
              // Place object with potential orientation
              locationSelect.val(eventData.description.waypoint);
              if (eventData.description.orientation !== undefined) {
                orientationInput.val(eventData.description.orientation);
              } else {
                orientationInput.val('');
              }
            }
            console.log(`Set location to ${eventData.description}, result:`, locationSelect.val());
          } else if (eventData.category === 'go_to_zone') {
            if (eventData.zone) {
              const zoneSelect = eventDiv.find('.event-zone');
              zoneSelect.val(eventData.zone);
              zoneSelect.trigger('change'); // Populate places
              console.log(`Set zone to ${eventData.zone}, result:`, zoneSelect.val());
            }
            if (eventData.types && Array.isArray(eventData.types)) {
              eventDiv.find('.event-zone-types').val(eventData.types);
            }
            if (eventData.places && Array.isArray(eventData.places)) {
              setTimeout(() => {
                eventData.places.forEach(place => {
                  let waypointName, orientation;
                  
                  if (typeof place === 'string') {
                    waypointName = place;
                    orientation = undefined;
                  } else if (place.waypoint) {
                    waypointName = place.waypoint;
                    orientation = place.orientation;
                  } else if (place.name) {
                    // Legacy support for old format
                    waypointName = place.name;
                    orientation = place.orientation;
                  }
                  
                  if (waypointName) {
                    const availableContainer = eventDiv.find('.available-waypoints');
                    const selectedContainer = eventDiv.find('.selected-waypoints');
                    const availableItem = availableContainer.find(`[data-waypoint="${waypointName}"]`);
                    
                    if (availableItem.length > 0) {
                      // Find the display name from available item
                      const displayName = availableItem.find('span').text();
                      
                      // Add to selected (this will call our function)
                      const addToSelectedWaypoints = eventDiv.closest('.event-details').data('addToSelectedWaypoints');
                      if (typeof addToSelectedWaypoints === 'function') {
                        addToSelectedWaypoints(waypointName, displayName, selectedContainer, availableContainer);
                      } else {
                        // Fallback - directly add to selected
                        availableItem.click();
                      }
                      
                      // Set orientation if provided
                      if (orientation !== undefined) {
                        setTimeout(() => {
                          const selectedItem = selectedContainer.find(`[data-waypoint="${waypointName}"]`);
                          selectedItem.find('.waypoint-orientation').val(orientation);
                        }, 10);
                      }
                    }
                  }
                });
                console.log(`Set zone places from saved data:`, eventData.places);
              }, 100);
            }
            if (eventData.facing !== undefined) {
              eventDiv.find('.event-zone-facing').val(eventData.facing);
            }
          } else if (eventData.category === 'perform_action') {
            if (eventData.action_category) {
              eventDiv.find('.event-action-category').val(eventData.action_category);
            }
            if (eventData.action_description) {
              eventDiv.find('.event-action-description').val(eventData.action_description);
            }
            if (eventData.duration_estimate) {
              eventDiv.find('.event-duration-estimate').val(eventData.duration_estimate);
            }
          }
        }
      });
    },
    
    refreshAllEventDropdowns: function(container) {
      // Refresh dropdowns for all existing events when RMF data is updated
      const currentEvents = []; // Store current event data
      
      container.find('.event-item').each(function() {
        const eventDiv = $(this);
        const category = eventDiv.find('.event-category').val();
        const currentData = { category };
        
        // Preserve current values
        if (category === 'go_to_place') {
          const locationName = eventDiv.find('.event-location').val();
          const orientation = eventDiv.find('.event-orientation').val();
          
          if (orientation && orientation.trim() !== '') {
            currentData.description = {
              waypoint: locationName,
              orientation: parseFloat(orientation)
            };
          } else {
            currentData.description = locationName;
          }
        } else if (category === 'go_to_zone') {
          currentData.zone = eventDiv.find('.event-zone').val();
          const selectedTypes = eventDiv.find('.event-zone-types').val();
          if (selectedTypes && selectedTypes.length > 0) {
            currentData.types = selectedTypes;
          }
          const selectedPlaces = [];
          eventDiv.find('.selected-waypoint-item').each(function() {
            const waypointName = $(this).data('waypoint');
            const orientationInput = $(this).find('.waypoint-orientation');
            const orientation = orientationInput.val();
            
            if (orientation && orientation.trim()) {
              selectedPlaces.push({
                waypoint: waypointName,
                orientation: parseFloat(orientation)
              });
            } else {
              selectedPlaces.push({ waypoint: waypointName });
            }
          });
          if (selectedPlaces.length > 0) {
            currentData.places = selectedPlaces;
          }
          const facing = eventDiv.find('.event-zone-facing').val();
          if (facing && facing.trim()) {
            currentData.facing = parseFloat(facing);
          }
        } else if (category === 'perform_action') {
          currentData.action_category = eventDiv.find('.event-action-category').val();
          currentData.action_description = eventDiv.find('.event-action-description').val();
          currentData.duration_estimate = parseInt(eventDiv.find('.event-duration-estimate').val()) || 30000;
        }
        
        currentEvents.push(currentData);
        
        // Refresh the event details (this repopulates dropdowns)
        TaskV2EventUtils.updateEventDetails(eventDiv, category, {});
      });
      
      // Restore the values after dropdowns are refreshed
      setTimeout(() => {
        TaskV2EventUtils.restoreEventValues(container, currentEvents);
      }, 100);
    }
  };

  // RMF Form Utilities specific to TaskV2
  const TaskV2RMFUtils = {
    populateRobotDropdown: function(options = {}) {
      const { node, selectId = 'node-input-robot_name', placeholder = 'Use msg.rmf_robot_name', valueProperty = 'robot_name' } = options;
      const select = $(`#${selectId}`);
      const currentValue = node.isLoaded ? select.val() : node[valueProperty];
      
      select.empty().append(`<option value="">${placeholder}</option>`);
      
      if (node.rmfData && node.rmfData.robots && node.rmfData.robots.length > 0) {
        node.rmfData.robots.forEach(robot => {
          select.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
        });
      }
      
      select.val(currentValue || '');
    },

    populateFleetDropdown: function(options = {}) {
      const { node, selectId = 'node-input-robot_fleet', placeholder = 'Use msg.rmf_robot_fleet', valueProperty = 'robot_fleet' } = options;
      const select = $(`#${selectId}`);
      const currentValue = node.isLoaded ? select.val() : node[valueProperty];
      
      select.empty().append(`<option value="">${placeholder}</option>`);
      
      if (node.rmfData && node.rmfData.fleets && node.rmfData.fleets.length > 0) {
        node.rmfData.fleets.forEach(fleet => {
          select.append(`<option value="${fleet}">${fleet}</option>`);
        });
      }
      
      select.val(currentValue || '');
    },

    setupRobotFleetHandlers: function(options = {}) {
      const { node, robotSelectId = 'node-input-robot_name', fleetSelectId = 'node-input-robot_fleet' } = options;
      const robotSelect = $(`#${robotSelectId}`);
      const fleetSelect = $(`#${fleetSelectId}`);

      robotSelect.off('change').on('change', function() {
        const selectedRobot = $(this).val();
        const selectedOption = $(this).find('option:selected');
        const robotFleet = selectedOption.data('fleet');
        
        if (selectedRobot && selectedRobot !== '' && robotFleet) {
          fleetSelect.val(robotFleet);
        } else {
          fleetSelect.val('');
        }
      });

      fleetSelect.off('change').on('change', function() {
        const selectedFleet = $(this).val();
        const currentRobot = robotSelect.val();
        
        if (currentRobot && selectedFleet && node.rmfData && node.rmfData.robots) {
          const robot = node.rmfData.robots.find(r => r.name === currentRobot);
          if (robot && robot.fleet !== selectedFleet) {
            robotSelect.val('');
          }
        }
        
        if (selectedFleet && selectedFleet !== '') {
          robotSelect.empty().append('<option value="">Use msg.rmf_robot_name</option>');
          if (node.rmfData && node.rmfData.robots) {
            node.rmfData.robots.forEach(robot => {
              if (robot.fleet === selectedFleet) {
                robotSelect.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
              }
            });
          }
          const robotFromFleet = node.rmfData.robots ? node.rmfData.robots.find(r => r.name === currentRobot && r.fleet === selectedFleet) : null;
          if (robotFromFleet) {
            robotSelect.val(currentRobot);
          }
        } else {
          robotSelect.empty().append('<option value="">Use msg.rmf_robot_name</option>');
          if (node.rmfData && node.rmfData.robots) {
            node.rmfData.robots.forEach(robot => {
              robotSelect.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
            });
          }
          robotSelect.val(currentRobot);
        }
      });
    },

    showDataStatus: function(message, type = 'info', configSelectId = 'node-input-config') {
      $('.rmf-data-status').remove();
      let color = '#2196f3', icon = 'fa-info-circle';
      if (type === 'error') { color = '#f44336'; icon = 'fa-exclamation-triangle'; }
      else if (type === 'success') { color = '#4caf50'; icon = 'fa-check-circle'; }
      const statusDiv = $(`<div class="rmf-data-status form-tips" style="color: ${color}; margin-top: 10px;"><i class="fa ${icon}" style="margin-right: 5px;"></i>${message}</div>`);
      $(`#${configSelectId}`).closest('.form-row').after(statusDiv);
    }
  };

  // Helper functions
  function getZoneVertices(zone) {
    return zone.vertices || zone.zone_vertices || [];
  }
  
  function getVertexLevel(vertex) {
    if (vertex.params && vertex.params.length > 0) {
      const mapNameParam = vertex.params.find(p => p.name === 'map_name');
      if (mapNameParam && mapNameParam.value_string) {
        return mapNameParam.value_string;
      }
    }
    return 'L1'; // Default level
  }

  RED.nodes.registerType('start-taskV2', {
    category: 'RMF v1 (OLD)',
    color: '#87CEEB',
    defaults: {
      name: { value: '' },
      config: { type: 'rmf-config', required: true },
      robot_name: { value: '' },
      robot_fleet: { value: '' },
      task_category: { value: '' },
      task_detail: { value: '' },
      events: { value: [] }
    },
    inputs: 1,
    outputs: 3,
    outputLabels: ["success", "failed", "status"],
    icon: 'rmf.svg',
    label: function () {
      return this.name || 'Create Task';
    },
    paletteLabel: 'Create Task',
    oneditprepare: function() {
      const node = this;
      
      // Set the current node reference for event utilities
      TaskV2EventUtils.setCurrentNode(node);
      
      console.log('Node oneditprepare - saved events:', node.events);
      
      // Initialize data storage (same structure as goto-place)
      node.rmfData = {
        robots: [],
        fleets: [],
        navGraphs: [],
        zones: []
      };
      
      // Load RMF data
      loadRMFData();
      
      // Setup change handlers
      setupChangeHandlers();
      
      // Setup refresh button
      setupRefreshButton();
      
      // Setup events management
      setupEventsManagement();
      
      function loadRMFData() {
        $.getJSON('/rmf/data', function(data) {
          node.rmfData = data;
          
          if (data.status === 'not_initialized') {
            TaskV2RMFUtils.showDataStatus('RMF not initialized. Deploy RMF Config node first.', 'info');
          } else if (data.status === 'error') {
            TaskV2RMFUtils.showDataStatus('Error loading RMF data: ' + data.message, 'error');
          } else if (data.robots.length === 0) {
            TaskV2RMFUtils.showDataStatus('No RMF data available. Check RMF system status.', 'info');
          } else {
            const locationCount = (data.navGraphs || []).reduce((count, ng) => count + (ng.vertices || []).length, 0);
            const zoneCount = (data.zones || []).length;
            TaskV2RMFUtils.showDataStatus(`Loaded ${data.robots.length} robots, ${locationCount} locations, ${zoneCount} zones`, 'success');
          }
          
          TaskV2RMFUtils.populateRobotDropdown({ node });
          TaskV2RMFUtils.populateFleetDropdown({ node });
          
          // Refresh event dropdowns with new data
          const eventsContainer = $('#events-container');
          if (eventsContainer.length > 0) {
            TaskV2EventUtils.refreshAllEventDropdowns(eventsContainer);
            
            // If we have saved events, restore their values after refresh
            if (node.events && node.events.length > 0) {
              setTimeout(() => {
                TaskV2EventUtils.restoreEventValues(eventsContainer, node.events);
              }, 200);
            }
          }
        }).fail(function(xhr, status, error) {
          TaskV2RMFUtils.showDataStatus('Failed to connect to RMF data source', 'error');
          node.rmfData = { robots: [], fleets: [], navGraphs: [], zones: [] };
          TaskV2RMFUtils.populateRobotDropdown({ node });
          TaskV2RMFUtils.populateFleetDropdown({ node });
        });
      }
      
      function setupRefreshButton() {
        $('#refresh-rmf-data').on('click', function() {
          const button = $(this);
          const originalText = button.html();
          
          button.html('<i class="fa fa-spinner fa-spin"></i> Loading...');
          button.prop('disabled', true);
          
          loadRMFData();
          
          setTimeout(() => {
            button.html(originalText);
            button.prop('disabled', false);
            
            // Refresh event dropdowns after data reload
            const eventsContainer = $('#events-container');
            if (eventsContainer.length > 0) {
              TaskV2EventUtils.refreshAllEventDropdowns(eventsContainer);
              
              // If we have saved events, restore their values after refresh
              if (node.events && node.events.length > 0) {
                setTimeout(() => {
                  TaskV2EventUtils.restoreEventValues(eventsContainer, node.events);
                }, 200);
              }
            }
          }, 1000);
        });
      }
      
      function setupChangeHandlers() {
        TaskV2RMFUtils.setupRobotFleetHandlers({ node });
      }
      
      function setupEventsManagement() {
        const eventsContainer = $('#events-container');
        
        // Add event button
        $('#add-event').on('click', function() {
          TaskV2EventUtils.addEvent(eventsContainer);
        });
        
        // Initialize with existing events or default
        TaskV2EventUtils.setEventsData(eventsContainer, node.events);
        
        // If we have RMF data already loaded and events, restore values
        if (node.rmfData && (node.rmfData.navGraphs?.length > 0 || node.rmfData.zones?.length > 0) && node.events?.length > 0) {
          setTimeout(() => {
            TaskV2EventUtils.restoreEventValues(eventsContainer, node.events);
          }, 200);
        }
      }
    },
    
    oneditsave: function() {
      // Save events data
      const eventsContainer = $('#events-container');
      this.events = TaskV2EventUtils.getEventsData(eventsContainer);
    }
  });
</script>

<script type="text/html" data-template-name="start-taskV2">
  <div class="form-row">
    <label for="node-input-name">Name</label>
    <input type="text" id="node-input-name">
  </div>
  
  <div class="form-row">
    <label for="node-input-config"><i class="fa fa-cogs"></i> RMF Config</label>
    <input type="text" id="node-input-config" style="width: 60%;">
    <button type="button" id="refresh-rmf-data" class="red-ui-button" style="margin-left: 10px; width: auto;">
      <i class="fa fa-refresh"></i> Refresh Data
    </button>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_name">Robot Name</label>
    <select id="node-input-robot_name" style="width: 100%;">
      <option value="">Use msg.rmf_robot_name (dispatch)</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_fleet">Robot Fleet</label>
    <select id="node-input-robot_fleet" style="width: 100%;">
      <option value="">Use msg.rmf_robot_fleet (dispatch)</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-task_category">Task Title</label>
    <input type="text" id="node-input-task_category" placeholder="e.g., Patrol, Cleaning, Custom Task" style="width: 100%;">
  </div>
  
  <div class="form-row">
    <label for="node-input-task_detail">Task Detail</label>
    <input type="text" id="node-input-task_detail" placeholder="Optional description" style="width: 100%;">
  </div>
  
  <div class="form-row">
    <label>Events</label>
    <div style="margin-top: 10px;">
      <button type="button" id="add-event" class="red-ui-button">
        <i class="fa fa-plus"></i> Add Event
      </button>
    </div>
    <div id="events-container" style="margin-top: 10px; max-height: 400px; overflow-y: auto;">
      <!-- Events will be dynamically added here -->
    </div>
  </div>
  
  <div class="form-tips">
    <b>RMF Task V2:</b><br/>
    Creates static compose tasks with predefined sequences of events. Unlike Dynamic Events, Task V2 executes a fixed workflow from start to completion.<br/><br/>
    
    <b>Robot Assignment:</b><br/>
    • Specify robot name + fleet for dedicated assignment<br/>
    • Leave empty for automatic dispatch to any available robot<br/><br/>
    
    <b>Events:</b><br/>
    • Go To Place: Navigate to a specific waypoint location<br/>
    • Go To Zone: Navigate to a zone with priority-ordered waypoint selection and individual orientations<br/>
    • Perform Action: Execute custom actions (teleop, cleaning, etc.)<br/>
    • Events execute in order as a sequence within a single phase
  </div>
</script>

<script type="text/html" data-help-name="start-taskV2">
  <p>Creates complete robot task workflows with predefined action sequences (RMF 1.0 compose tasks). This legacy approach defines all actions upfront in a single monolithic task.</p>
  
  <p><strong>🆕 For new projects, consider using RMF Dynamic Events instead:</strong> start-task → goto-place → perform-action → end-task for more flexible, real-time control.</p>
  
  <h3>Configuration</h3>
  <dl class="message-properties">
    <dt>Robot Name <span class="property-type">string</span></dt>
    <dd>Target robot name (optional for dispatch). Select from dropdown or use "Use msg.rmf_robot_name".</dd>
    
    <dt>Robot Fleet <span class="property-type">string</span></dt>
    <dd>Target robot fleet (optional for dispatch). Auto-selected when robot is chosen.</dd>
    
    <dt>Task Title <span class="property-type">string</span></dt>
    <dd>Descriptive category for the task (e.g., "Patrol", "Cleaning").</dd>
    
    <dt>Task Detail <span class="property-type">string</span></dt>
    <dd>Optional detailed description of the task.</dd>
    
    <dt>Events <span class="property-type">array</span></dt>
    <dd>Sequence of events to execute. Events run in order within a single phase.</dd>
  </dl>
  
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>msg.rmf_robot_name <span class="property-type">string</span></dt>
    <dd>Robot name (overrides config)</dd>
    
    <dt>msg.rmf_robot_fleet <span class="property-type">string</span></dt>
    <dd>Robot fleet (overrides config)</dd>
    
    <dt>msg.task_title <span class="property-type">string</span></dt>
    <dd>Task title (overrides config)</dd>
    
    <dt>msg.task_detail <span class="property-type">string</span></dt>
    <dd>Task detail (overrides config)</dd>
    
    <dt>msg.events <span class="property-type">array</span></dt>
    <dd>Events array (overrides config)</dd>
  </dl>
  
  <h3>Outputs</h3>
  <ol class="node-ports">
    <li>Success
      <dl class="message-properties">
        <dt>payload.status <span class="property-type">string</span></dt>
        <dd>"completed" when task finishes successfully</dd>
        <dt>payload.task_id <span class="property-type">string</span></dt>
        <dd>The RMF task ID</dd>
        <dt>payload.robot_name <span class="property-type">string</span></dt>
        <dd>Assigned robot name</dd>
        <dt>payload.robot_fleet <span class="property-type">string</span></dt>
        <dd>Assigned robot fleet</dd>
        <dt>payload.final_status <span class="property-type">string</span></dt>
        <dd>Final task status from RMF</dd>
      </dl>
    </li>
    <li>Failed
      <dl class="message-properties">
        <dt>payload.status <span class="property-type">string</span></dt>
        <dd>"failed", "cancelled", "waiting", or "error"</dd>
        <dt>payload.reason <span class="property-type">string</span></dt>
        <dd>Description of the failure</dd>
        <dt>payload.task_id <span class="property-type">string</span></dt>
        <dd>The RMF task ID (if created)</dd>
      </dl>
    </li>
    <li>Status
      <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Raw status data from RMF task manager (varies by update type)</dd>
        <dt>topic <span class="property-type">string</span></dt>
        <dd>Message topic: "task/{task_id}/status", "task/{task_id}/feedback", or "task/{task_id}/complete"</dd>
        <dt>timestamp <span class="property-type">string</span></dt>
        <dd>ISO timestamp when the status update was received</dd>
      </dl>
      <p><strong>Status Update Types:</strong></p>
      <ul>
        <li><strong>Task Status:</strong> Direct RMF task state updates with complete task information</li>
        <li><strong>Goal Feedback:</strong> Progress updates during task execution (progress, current_phase, etc.)</li>
        <li><strong>Goal Complete:</strong> Final completion data with execution time and results</li>
      </ul>
    </li>
  </ol>
  
  <h3>Details</h3>
  <p>This node creates RMF Task V2 compose tasks with static event sequences. Unlike Dynamic Events, these tasks have a predefined workflow that executes from start to completion without runtime modification.</p>
  
  <p><strong>Task Structure:</strong> Task → Phase → Sequence → Events</p>
  
  <p><strong>Supported Events:</strong></p>
  <ul>
    <li><strong>Go To Place:</strong> Navigate robot to a specific waypoint</li>
    <li><strong>Go To Zone:</strong> Navigate robot to a zone with priority-ordered waypoint selection, individual waypoint orientations, and facing direction</li>
    <li><strong>Perform Action:</strong> Execute custom actions with configurable category and description</li>
  </ul>
  
  <p><strong>Assignment:</strong> Specify robot/fleet for dedicated assignment, or leave empty for automatic dispatch to any available robot.</p>
</script>
