<style>
.waypoint-placeholder {
  background: #ffeb3b !important;
  border: 2px dashed #ff9800 !important;
  height: 30px !important;
  margin: 2px 0 !important;
}
</style>

<script type="text/javascript">
  // Task and Event management utilities
  const TaskV2Utils = {
    currentNode: null,
    
    setCurrentNode: function(node) {
      this.currentNode = node;
    },
    
    // Task type management
    setupTaskType: function(container, taskType, taskData = {}) {
      container.empty();
      
      if (taskType === 'compose') {
        this.setupComposeTask(container, taskData);
      } else if (taskType === 'patrol') {
        this.setupPatrolTask(container, taskData);
      } else if (taskType === 'zone') {
        this.setupZoneTask(container, taskData);
      } else if (taskType === 'couple') {
        this.setupCoupleTask(container, taskData);
      } else if (taskType === 'decouple') {
        this.setupDecoupleTask(container, taskData);
      }
    },
    
    setupComposeTask: function(container, taskData = {}) {
      container.html(`
        <div class="form-row">
          <label>Task Category</label>
          <input type="text" class="task-category" placeholder="e.g., Custom Task" style="width: 100%;" value="${taskData.category || ''}">
        </div>
        <div class="form-row">
          <label>Task Detail</label>
          <input type="text" class="task-detail" placeholder="Optional description" style="width: 100%;" value="${taskData.detail || ''}">
        </div>
        <div class="form-row">
          <label>Phases</label>
          <div style="margin-top: 10px;">
            <button type="button" class="add-phase red-ui-button">
              <i class="fa fa-plus"></i> Add Phase
            </button>
          </div>
          <div class="phases-container" style="margin-top: 10px; max-height: 400px; overflow-y: auto;">
            <!-- Phases will be dynamically added here -->
          </div>
        </div>
      `);
      
      // Setup add phase handler
      container.find('.add-phase').on('click', function() {
        TaskV2Utils.addPhase(container.find('.phases-container'));
      });
      
      // Initialize with existing phases or add default
      if (taskData.phases && taskData.phases.length > 0) {
        taskData.phases.forEach(phaseData => {
          TaskV2Utils.addPhase(container.find('.phases-container'), phaseData);
        });
      } else {
        TaskV2Utils.addPhase(container.find('.phases-container'));
      }
    },
    
    setupPatrolTask: function(container, taskData = {}) {
      container.html(`
        <div class="form-row">
          <label>Patrol Places</label>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <!-- Available waypoints -->
            <div style="flex: 1;">
              <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Available Waypoints</h4>
              <div class="patrol-available-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 150px; max-height: 200px; overflow-y: auto; background: #fafafa;">
                <!-- Available waypoints will be populated here -->
              </div>
            </div>
            
            <!-- Selected waypoints (ordered) -->
            <div style="flex: 1;">
              <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Selected Places (Patrol Order)</h4>
              <div class="patrol-selected-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 150px; max-height: 200px; overflow-y: auto; background: #f0f8ff;">
                <!-- Selected waypoints will be shown here in order -->
              </div>
            </div>
          </div>
          <div class="form-tips">Click waypoints to add/remove from patrol route. Drag selected waypoints to reorder patrol sequence.</div>
        </div>
        <div class="form-row">
          <label>Number of Rounds</label>
          <input type="number" class="patrol-rounds" min="1" value="${taskData.rounds || 1}" style="width: 100%;" disabled>
          <div class="form-tips patrol-validation" style="color: #d32f2f; margin-top: 5px; display: none;">⚠️ Please select at least one waypoint for the patrol route.</div>
        </div>
      `);
      
      // Populate waypoints
      this.populatePatrolWaypoints(container, taskData);
      
      // Enable rounds input only when waypoints are selected
      this.validatePatrolFields(container);
    },
    
    populatePatrolWaypoints: function(container, taskData = {}) {
      const node = this.currentNode;
      if (node && node.rmfData && node.rmfData.navGraphs) {
        const availableContainer = container.find('.patrol-available-waypoints');
        const selectedContainer = container.find('.patrol-selected-waypoints');
        const waypoints = new Map();
        
        // Extract waypoints from nav graphs
        node.rmfData.navGraphs.forEach(navGraph => {
          if (navGraph.vertices) {
            navGraph.vertices.forEach(vertex => {
              if (vertex.name && vertex.name.trim() !== '') {
                waypoints.set(vertex.name, {
                  name: vertex.name,
                  fleet: navGraph.fleet || navGraph.name
                });
              }
            });
          }
        });
        
        // Populate available waypoints
        Array.from(waypoints.values()).sort((a, b) => a.name.localeCompare(b.name)).forEach(waypoint => {
          const waypointItem = $(`
            <div class="patrol-waypoint-item" data-waypoint="${waypoint.name}" style="padding: 3px 6px; margin: 2px; background: #fff; border: 1px solid #ddd; cursor: pointer; border-radius: 3px;">
              ${waypoint.name}
            </div>
          `);
          
          waypointItem.on('click', function() {
            const waypointName = $(this).data('waypoint');
            TaskV2Utils.addPatrolWaypoint(selectedContainer, waypointName);
            $(this).hide();
          });
          
          availableContainer.append(waypointItem);
        });
        
        // Initialize with existing places
        if (taskData.places && taskData.places.length > 0) {
          taskData.places.forEach(place => {
            TaskV2Utils.addPatrolWaypoint(selectedContainer, place);
            availableContainer.find(`[data-waypoint="${place}"]`).hide();
          });
        }
      }
    },
    
    addPatrolWaypoint: function(selectedContainer, waypointName) {
      const waypointItem = $(`
        <div class="patrol-selected-item" data-waypoint="${waypointName}" style="padding: 3px 6px; margin: 2px; background: #e3f2fd; border: 1px solid #2196F3; cursor: move; border-radius: 3px; position: relative;">
          <span>${waypointName}</span>
          <button type="button" class="remove-patrol-waypoint" style="float: right; background: none; border: none; color: #d32f2f; font-size: 12px; cursor: pointer;">&times;</button>
        </div>
      `);
      
      waypointItem.find('.remove-patrol-waypoint').on('click', function(e) {
        e.stopPropagation();
        const waypoint = waypointItem.data('waypoint');
        waypointItem.remove();
        // Show the waypoint back in available list
        selectedContainer.closest('.form-row').find(`.patrol-waypoint-item[data-waypoint="${waypoint}"]`).show();
        // Update validation after removing waypoint
        const container = selectedContainer.closest('.form-row').parent();
        TaskV2Utils.validatePatrolFields(container);
      });
      
      selectedContainer.append(waypointItem);
      
      // Update validation after adding waypoint
      const container = selectedContainer.closest('.form-row').parent();
      TaskV2Utils.validatePatrolFields(container);
    },
    
    validatePatrolFields: function(container) {
      const selectedWaypoints = container.find('.patrol-selected-item');
      const roundsInput = container.find('.patrol-rounds');
      const validationMsg = container.find('.patrol-validation');
      
      if (selectedWaypoints.length > 0) {
        roundsInput.prop('disabled', false);
        validationMsg.hide();
      } else {
        roundsInput.prop('disabled', true);
        validationMsg.show();
      }
    },
    
    setupZoneTask: function(container, taskData = {}) {
      container.html(`
        <div class="form-row">
          <label>Zone:</label>
          <select class="zone-select" style="width: 100%;">
            <option value="">Select zone...</option>
          </select>
        </div>
        <div class="form-row">
          <label>Zone Types (optional):</label>
          <select class="zone-types" multiple style="width: 100%; height: 80px;" disabled>
            <option value="all" selected>All</option>
            <option value="human_facing">Human Facing</option>
            <option value="left">Left</option>
            <option value="right">Right</option>
            <option value="center">Center</option>
            <option value="top">Top</option>
            <option value="bottom">Bottom</option>
          </select>
          <div class="form-tips">Hold Ctrl/Cmd to select multiple zone entry types. 'All' is mutually exclusive with other selections.</div>
        </div>
        <div class="form-row">
          <label>Preferred Places (optional):</label>
          <div class="zone-places-container" style="border: 1px solid #ddd; padding: 10px; max-height: 300px; overflow-y: auto; opacity: 0.5; pointer-events: none;">
            <div class="form-tips" style="margin-bottom: 10px;">Select waypoints from available list. Drag selected waypoints to reorder priority (top = highest priority).</div>
            
            <div style="display: flex; gap: 10px;">
              <!-- Available waypoints -->
              <div style="flex: 1;">
                <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Available Waypoints</h4>
                <div class="zone-available-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #fafafa;">
                  <!-- Available waypoints will be populated here -->
                </div>
              </div>
              
              <!-- Selected waypoints (ordered) -->
              <div style="flex: 1;">
                <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Selected Waypoints (Priority Order)</h4>
                <div class="zone-selected-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #f0f8ff;">
                  <!-- Selected waypoints will be shown here in order -->
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="form-row">
          <label>Final Facing (radians, optional):</label>
          <input type="number" class="zone-facing" step="0.01" placeholder="e.g., 1.57 (90 degrees) - applies if no waypoint orientations set" style="width: 100%;" disabled>
        </div>
        <div class="zone-validation" style="color: #d32f2f; margin-top: 10px; display: none;">⚠️ Please select a zone first to enable configuration options.</div>
      `);
      
      // Populate zones
      this.populateZoneData(container, taskData);
      
      // Setup zone validation
      this.validateZoneFields(container);
    },
    
    populateZoneData: function(container, taskData = {}) {
      const node = this.currentNode;
      
      // Populate zone dropdown
      if (node && node.rmfData && node.rmfData.zones) {
        const zoneSelect = container.find('.zone-select');
        node.rmfData.zones.forEach(zone => {
          if (zone.name && zone.name.trim() !== '') {
            zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
          }
        });
        if (taskData.zone && taskData.zone.zone) {
          zoneSelect.val(taskData.zone.zone);
        }
      }
      
      // Setup zone waypoint filtering (only show waypoints within selected zone)
      if (node && node.rmfData && node.rmfData.zones) {
        const zoneSelect = container.find('.zone-select');
        const availableContainer = container.find('.zone-available-waypoints');
        const selectedContainer = container.find('.zone-selected-waypoints');
        
        // Update waypoints when zone changes
        zoneSelect.on('change', function() {
          const selectedZone = $(this).val();
          availableContainer.empty();
          selectedContainer.empty();
          
          // Update field validation
          TaskV2Utils.validateZoneFields(container);
          
          if (selectedZone) {
            const zone = node.rmfData.zones.find(z => z.name === selectedZone);
            if (zone) {
              console.log('Zone data for', selectedZone, ':', zone);
              
              const zoneVertices = getZoneVertices(zone);
              console.log('Zone vertices:', zoneVertices);
              
              if (zoneVertices.length > 0) {
                zoneVertices.forEach((vertex, index) => {
                  let vertexName, displayName, vertexValue;
                  
                  // Handle different zone vertex structures
                  if (typeof vertex === 'object' && vertex.name) {
                    // Vertex object with name
                    vertexName = vertex.name;
                    vertexValue = vertex.name;
                    displayName = vertexName;
                  } else if (typeof vertex === 'number') {
                    // Vertex index - find corresponding vertex name from navGraphs
                    const graph = node.rmfData.navGraphs ? node.rmfData.navGraphs.find(g => 
                      g.name === zone.graph || g.vertices.length > vertex
                    ) : null;
                    
                    if (graph && graph.vertices[vertex]) {
                      vertexName = graph.vertices[vertex].name || `Vertex ${vertex}`;
                      vertexValue = vertexName;
                      displayName = `${vertexName} (Position ${index + 1})`;
                    } else {
                      vertexName = `Vertex ${vertex}`;
                      vertexValue = `vertex_${vertex}`;
                      displayName = `Position ${index + 1} (Index ${vertex})`;
                    }
                  } else {
                    // Fallback for other structures
                    vertexName = `Position ${index + 1}`;
                    vertexValue = `vertex_${index}`;
                    displayName = vertexName;
                  }
                  
                  // Create available waypoint item
                  const waypointItem = $(`
                    <div class="zone-waypoint-item" data-waypoint="${vertexValue}" style="padding: 5px; margin: 2px 0; background: white; border: 1px solid #ddd; cursor: pointer; border-radius: 3px; font-size: 11px;">
                      <span style="color: #333;">${displayName}</span>
                    </div>
                  `);
                  
                  waypointItem.on('click', function() {
                    const waypointValue = $(this).data('waypoint');
                    TaskV2Utils.addZoneWaypoint(selectedContainer, waypointValue, displayName);
                    $(this).hide();
                  });
                  
                  availableContainer.append(waypointItem);
                });
                
                // Make selected waypoints sortable (fallback if jQuery UI not available)
                try {
                  selectedContainer.sortable({
                    items: '.zone-selected-item',
                    placeholder: 'waypoint-placeholder',
                    tolerance: 'pointer',
                    cursor: 'move'
                  });
                } catch (e) {
                  console.log('jQuery UI sortable not available, using basic ordering');
                }
              }
            }
          }
        });
        
        // Initialize with existing zone and preferred places
        if (taskData.zone && taskData.zone.zone) {
          zoneSelect.val(taskData.zone.zone);
          zoneSelect.trigger('change'); // Populate waypoints for the selected zone
          
          // After waypoints are populated, restore selected places
          if (taskData.zone.preferred_places && taskData.zone.preferred_places.length > 0) {
            setTimeout(() => {
              taskData.zone.preferred_places.forEach(place => {
                const waypointItem = availableContainer.find(`[data-waypoint="${place}"]`);
                if (waypointItem.length > 0) {
                  const displayName = waypointItem.text();
                  TaskV2Utils.addZoneWaypoint(selectedContainer, place, displayName);
                  waypointItem.hide();
                }
              });
            }, 100);
          }
        }
      }
      
      // Set existing zone types
      if (taskData.zone && taskData.zone.zone_types) {
        const zoneTypesSelect = container.find('.zone-types');
        zoneTypesSelect.val(taskData.zone.zone_types);
      }
      
      // Set existing facing
      if (taskData.zone && taskData.zone.facing !== undefined) {
        container.find('.zone-facing').val(taskData.zone.facing);
      }
    },
    
    addZoneWaypoint: function(selectedContainer, waypointValue, displayName) {
      displayName = displayName || waypointValue;
      
      // Check if already selected
      if (selectedContainer.find(`[data-waypoint="${waypointValue}"]`).length > 0) {
        return;
      }
      
      const waypointItem = $(`
        <div class="zone-selected-item" data-waypoint="${waypointValue}" style="padding: 5px; margin: 2px 0; background: #e3f2fd; border: 1px solid #2196F3; cursor: move; border-radius: 3px; position: relative; font-size: 11px;">
          <span style="color: #333;">${displayName}</span>
          <button type="button" class="remove-zone-waypoint" style="float: right; background: none; border: none; color: #d32f2f; font-size: 12px; cursor: pointer;">&times;</button>
        </div>
      `);
      
      waypointItem.find('.remove-zone-waypoint').on('click', function(e) {
        e.stopPropagation();
        const waypoint = waypointItem.data('waypoint');
        waypointItem.remove();
        // Show the waypoint back in available list
        selectedContainer.closest('.zone-places-container').find(`.zone-waypoint-item[data-waypoint="${waypoint}"]`).show();
      });
      
      selectedContainer.append(waypointItem);
    },
    
    validateZoneFields: function(container) {
      const zoneSelect = container.find('.zone-select');
      const zoneTypes = container.find('.zone-types');
      const placesContainer = container.find('.zone-places-container');
      const facingInput = container.find('.zone-facing');
      const validationMsg = container.find('.zone-validation');
      
      const hasZone = zoneSelect.val() && zoneSelect.val() !== '';
      
      if (hasZone) {
        zoneTypes.prop('disabled', false);
        placesContainer.css({ 'opacity': '1', 'pointer-events': 'auto' });
        facingInput.prop('disabled', false);
        validationMsg.hide();
      } else {
        zoneTypes.prop('disabled', true);
        placesContainer.css({ 'opacity': '0.5', 'pointer-events': 'none' });
        facingInput.prop('disabled', true);
        validationMsg.show();
      }
    },
    
    setupCoupleTask: function(container, taskData = {}) {
      container.html(`
        <div class="form-row">
          <label>Coupling Zone</label>
          <select class="couple-zone-select" style="width: 100%;">
            <option value="">Select zone where robots will couple...</option>
          </select>
        </div>
        <div class="form-row">
          <label>Couple Configuration</label>
          <div class="couple-config" style="border: 1px solid #ddd; padding: 10px; opacity: 0.5; pointer-events: none;">
            <div class="form-row">
              <label>Number of Robots:</label>
              <input type="number" class="couple-robots" min="2" value="${taskData.couple && taskData.couple.number_of_robots || 2}" style="width: 100%;" disabled>
              <div class="form-tips">Specify how many robots should participate in the coupling operation.</div>
            </div>
            <div class="form-row">
              <label>Estimated Duration (seconds):</label>
              <input type="number" class="couple-duration" min="0" value="${taskData.couple && taskData.couple.estimated_duration || 60}" style="width: 100%;" disabled>
              <div class="form-tips">Expected time to complete the coupling operation.</div>
            </div>
          </div>
        </div>
        <div class="couple-validation" style="color: #d32f2f; margin-top: 10px; display: none;">⚠️ Please select a coupling zone first to enable configuration options.</div>
      `);
      
      // Populate zones and setup validation
      this.populateCoupleData(container, taskData);
    },
    
    populateCoupleData: function(container, taskData = {}) {
      const node = this.currentNode;
      if (node && node.rmfData && node.rmfData.zones) {
        const zoneSelect = container.find('.couple-zone-select');
        node.rmfData.zones.forEach(zone => {
          if (zone.name && zone.name.trim() !== '') {
            zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
          }
        });
        
        // Setup zone change handler for validation
        zoneSelect.on('change', function() {
          TaskV2Utils.validateCoupleFields(container);
        });
        
        if (taskData.zone && taskData.zone.zone) {
          zoneSelect.val(taskData.zone.zone);
        }
        
        // Initial validation
        this.validateCoupleFields(container);
      }
    },
    
    validateCoupleFields: function(container) {
      const zoneSelect = container.find('.couple-zone-select');
      const coupleConfig = container.find('.couple-config');
      const robotsInput = container.find('.couple-robots');
      const durationInput = container.find('.couple-duration');
      const validationMsg = container.find('.couple-validation');
      
      const hasZone = zoneSelect.val() && zoneSelect.val() !== '';
      
      if (hasZone) {
        coupleConfig.css({ 'opacity': '1', 'pointer-events': 'auto' });
        robotsInput.prop('disabled', false);
        durationInput.prop('disabled', false);
        validationMsg.hide();
      } else {
        coupleConfig.css({ 'opacity': '0.5', 'pointer-events': 'none' });
        robotsInput.prop('disabled', true);
        durationInput.prop('disabled', true);
        validationMsg.show();
      }
    },
    
    setupDecoupleTask: function(container, taskData = {}) {
      container.html(`
        <div class="form-row">
          <label>Decoupling Zone</label>
          <select class="decouple-zone-select" style="width: 100%;">
            <option value="">Select zone where robots will decouple...</option>
          </select>
        </div>
        <div class="form-row">
          <label>Decouple Configuration</label>
          <div class="decouple-config" style="border: 1px solid #ddd; padding: 10px; opacity: 0.5; pointer-events: none;">
            <div class="form-row">
              <label>Estimated Duration (seconds):</label>
              <input type="number" class="decouple-duration" min="0" value="${taskData.decouple && taskData.decouple.estimated_duration || 60}" style="width: 100%;" disabled>
              <div class="form-tips">Expected time to complete the decoupling operation.</div>
            </div>
          </div>
        </div>
        <div class="decouple-validation" style="color: #d32f2f; margin-top: 10px; display: none;">⚠️ Please select a decoupling zone first to enable configuration options.</div>
      `);
      
      // Populate zones and setup validation
      this.populateDecoupleData(container, taskData);
    },
    
    populateDecoupleData: function(container, taskData = {}) {
      const node = this.currentNode;
      if (node && node.rmfData && node.rmfData.zones) {
        const zoneSelect = container.find('.decouple-zone-select');
        node.rmfData.zones.forEach(zone => {
          if (zone.name && zone.name.trim() !== '') {
            zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
          }
        });
        
        // Setup zone change handler for validation
        zoneSelect.on('change', function() {
          TaskV2Utils.validateDecoupleFields(container);
        });
        
        if (taskData.zone && taskData.zone.zone) {
          zoneSelect.val(taskData.zone.zone);
        }
        
        // Initial validation
        this.validateDecoupleFields(container);
      }
    },
    
    validateDecoupleFields: function(container) {
      const zoneSelect = container.find('.decouple-zone-select');
      const decoupleConfig = container.find('.decouple-config');
      const durationInput = container.find('.decouple-duration');
      const validationMsg = container.find('.decouple-validation');
      
      const hasZone = zoneSelect.val() && zoneSelect.val() !== '';
      
      if (hasZone) {
        decoupleConfig.css({ 'opacity': '1', 'pointer-events': 'auto' });
        durationInput.prop('disabled', false);
        validationMsg.hide();
      } else {
        decoupleConfig.css({ 'opacity': '0.5', 'pointer-events': 'none' });
        durationInput.prop('disabled', true);
        validationMsg.show();
      }
    },
    
    // Phase management for compose tasks
    addPhase: function(phasesContainer, phaseData = {}) {
      const phaseId = Date.now() + Math.random();
      const phaseDiv = $(`
        <div class="phase-item" data-phase-id="${phaseId}" style="border: 2px solid #2196F3; padding: 15px; margin: 10px 0; background: #f8f9fa;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <label style="font-weight: bold; color: #2196F3;">Phase ${phasesContainer.children().length + 1}</label>
            <button type="button" class="remove-phase red-ui-button" style="background: #d32f2f;">
              <i class="fa fa-trash"></i> Remove Phase
            </button>
          </div>
          <div class="form-row">
            <label>Events in this Phase</label>
            <div style="margin-top: 10px;">
              <button type="button" class="add-event red-ui-button">
                <i class="fa fa-plus"></i> Add Event
              </button>
            </div>
            <div class="events-container" style="margin-top: 10px; border: 1px solid #ddd; padding: 10px; min-height: 60px;">
              <!-- Events will be dynamically added here -->
            </div>
          </div>
        </div>
      `);
      
      phasesContainer.append(phaseDiv);
      
      // Setup handlers
      phaseDiv.find('.remove-phase').on('click', function() {
        phaseDiv.remove();
        TaskV2Utils.updatePhaseLabels(phasesContainer);
      });
      
      phaseDiv.find('.add-event').on('click', function() {
        TaskV2EventUtils.addEvent(phaseDiv.find('.events-container'));
      });
      
      // Initialize with existing events or add default
      if (phaseData.events && phaseData.events.length > 0) {
        phaseData.events.forEach(eventData => {
          TaskV2EventUtils.addEvent(phaseDiv.find('.events-container'), eventData);
        });
      } else {
        TaskV2EventUtils.addEvent(phaseDiv.find('.events-container'));
      }
      
      return phaseDiv;
    },
    
    updatePhaseLabels: function(phasesContainer) {
      phasesContainer.find('.phase-item').each(function(index) {
        $(this).find('label').first().text(`Phase ${index + 1}`);
      });
    },
    
    // Get task data based on type
    getTaskData: function(container) {
      const taskType = $('#node-input-task_type').val();
      
      if (taskType === 'compose') {
        const taskData = {
          category: container.find('.task-category').val() || '',
          detail: container.find('.task-detail').val() || '',
          phases: []
        };
        
        container.find('.phase-item').each(function() {
          const phaseDiv = $(this);
          const phase = {
            events: []
          };
          
          phaseDiv.find('.event-item').each(function() {
            const eventDiv = $(this);
            const event = TaskV2EventUtils.getEventData(eventDiv);
            if (event) {
              phase.events.push(event);
            }
          });
          
          if (phase.events.length > 0) {
            taskData.phases.push(phase);
          }
        });
        
        return taskData;
      } else if (taskType === 'patrol') {
        const places = [];
        container.find('.patrol-selected-item').each(function() {
          places.push($(this).data('waypoint'));
        });
        
        return {
          places: places,
          rounds: parseInt(container.find('.patrol-rounds').val()) || 1
        };
      } else if (taskType === 'zone') {
        const zoneData = {
          zone: container.find('.zone-select').val()
        };
        
        // Get zone types
        const zoneTypes = [];
        container.find('.zone-types option:selected').each(function() {
          zoneTypes.push($(this).val());
        });
        if (zoneTypes.length > 0 && !zoneTypes.includes('all')) {
          zoneData.zone_types = zoneTypes;
        }
        
        // Get preferred places
        const places = [];
        container.find('.zone-selected-item').each(function() {
          places.push($(this).data('waypoint'));
        });
        if (places.length > 0) {
          zoneData.preferred_places = places;
        }
        
        // Get facing direction
        const facing = container.find('.zone-facing').val();
        if (facing !== '') {
          zoneData.facing = parseFloat(facing);
        }
        
        return {
          zone: zoneData
        };
      } else if (taskType === 'couple') {
        const selectedZone = container.find('.couple-zone-select').val();
        return {
          zone: {
            zone: selectedZone
          },
          couple: {
            number_of_robots: parseInt(container.find('.couple-robots').val()) || 2,
            expected_zone: selectedZone, // Use the same zone as expected_zone
            estimated_duration: parseInt(container.find('.couple-duration').val()) || 60
          }
        };
      } else if (taskType === 'decouple') {
        return {
          zone: {
            zone: container.find('.decouple-zone-select').val()
          },
          decouple: {
            estimated_duration: parseInt(container.find('.decouple-duration').val()) || 60
          }
        };
      }
      
      return {};
    }
  };

  // Event management utilities (reused from original)
  const TaskV2EventUtils = {
    currentNode: null,
    
    setCurrentNode: function(node) {
      this.currentNode = node;
    },
    
    addEvent: function(container, eventData = {}) {
      const eventId = Date.now() + Math.random();
      const eventDiv = $(`
        <div class="event-item" data-event-id="${eventId}" style="border: 1px solid #ddd; padding: 10px; margin: 5px 0; background: #f9f9f9;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <label style="font-weight: bold;">Event ${container.children().length + 1}</label>
            <button type="button" class="remove-event red-ui-button" style="background: #d32f2f;">
              <i class="fa fa-trash"></i> Remove
            </button>
          </div>
          
          <div class="form-row">
            <label>Event Type:</label>
            <select class="event-category" style="width: 100%;">
              <option value="go_to_place">Go To Place</option>
              <option value="go_to_zone">Go To Zone</option>
              <option value="perform_action">Perform Action</option>
              <option value="couple">Couple Action</option>
              <option value="decouple">Decouple Action</option>
            </select>
          </div>
          
          <div class="event-details">
            <!-- Event-specific fields will be inserted here -->
          </div>
        </div>
      `);
      
      container.append(eventDiv);
      
      // Set up event handlers
      eventDiv.find('.remove-event').on('click', function() {
        eventDiv.remove();
        TaskV2EventUtils.updateEventLabels(container);
      });
      
      eventDiv.find('.event-category').on('change', function() {
        TaskV2EventUtils.updateEventDetails(eventDiv, $(this).val());
      }).val(eventData.category || 'go_to_place');
      
      // Initialize event details
      TaskV2EventUtils.updateEventDetails(eventDiv, eventData.category || 'go_to_place', eventData);
      
      // If we have eventData, restore values after dropdown population
      if (eventData && Object.keys(eventData).length > 1) {
        setTimeout(() => {
          TaskV2EventUtils.restoreEventValues(eventDiv.parent(), [eventData]);
        }, 50);
      }
      
      return eventDiv;
    },
    
    updateEventLabels: function(container) {
      container.find('.event-item').each(function(index) {
        $(this).find('label').first().text(`Event ${index + 1}`);
      });
    },
    
    updateEventDetails: function(eventDiv, category, eventData = {}) {
      const detailsDiv = eventDiv.find('.event-details');
      detailsDiv.empty();
      
      if (category === 'go_to_place') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Location</label>
            <select class="event-location" style="width: 100%;">
              <option value="">Select waypoint...</option>
            </select>
          </div>
          <div class="form-row">
            <label>Orientation (radians)</label>
            <input type="number" class="event-orientation" min="-6.28" max="6.28" step="0.001" style="width: 100%;" placeholder="Optional: Final facing angle in radians">
            <div class="form-tips">Set the final facing direction (in radians) when the robot reaches the waypoint. Leave empty to use default facing.</div>
          </div>
        `);
        
        // Populate waypoints from RMF navGraphs data (waypoints only, no zones)
        const node = TaskV2EventUtils.currentNode;
        if (node && node.rmfData && node.rmfData.navGraphs) {
          console.log('Populating waypoints, navGraphs:', node.rmfData.navGraphs.length);
          const locationSelect = detailsDiv.find('.event-location');
          const waypoints = new Map(); // Use Map to avoid duplicates
          
          // Extract waypoints from nav graphs
          node.rmfData.navGraphs.forEach(navGraph => {
            if (navGraph.vertices) {
              navGraph.vertices.forEach(vertex => {
                if (vertex.name && vertex.name.trim() !== '') {
                  // Check if this vertex is part of a zone (exclude zone vertices)
                  const isPartOfZone = node.rmfData.zones && node.rmfData.zones.some(zone => {
                    const zoneVertices = getZoneVertices(zone);
                    if (zoneVertices.length === 0) return false;
                    return zoneVertices.some(zv => {
                      if (zv.name && zv.name === vertex.name) return true;
                      if (typeof zv === 'number' && vertex.index === zv) return true;
                      if (zv.x !== undefined && zv.y !== undefined && 
                          Math.abs(zv.x - vertex.x) < 0.01 && Math.abs(zv.y - vertex.y) < 0.01) {
                        return true;
                      }
                      return false;
                    });
                  });
                  
                  // Only add if it's not part of a zone
                  if (!isPartOfZone) {
                    waypoints.set(vertex.name, {
                      name: vertex.name,
                      fleet: navGraph.fleet || navGraph.name
                    });
                  }
                }
              });
            }
          });
          
          console.log('Found waypoints:', waypoints.size);
          
          // Populate dropdown with sorted waypoints
          Array.from(waypoints.values()).sort((a, b) => a.name.localeCompare(b.name)).forEach(waypoint => {
            locationSelect.append(`<option value="${waypoint.name}">${waypoint.name}</option>`);
          });
          
          // Set saved value if provided
          if (eventData.description) {
            locationSelect.val(eventData.description);
            console.log('Set waypoint value to:', eventData.description, 'Found in dropdown:', locationSelect.find(`option[value="${eventData.description}"]`).length > 0);
          }
        } else {
          console.log('No RMF data available for waypoints. Node:', !!node, 'rmfData:', node ? !!node.rmfData : 'no node', 'navGraphs:', node && node.rmfData ? node.rmfData.navGraphs?.length : 'no rmfData');
        }
        
      } else if (category === 'go_to_zone') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Zone:</label>
            <select class="event-zone" style="width: 100%;">
              <option value="">Select zone...</option>
            </select>
          </div>
          <div class="form-row">
            <label>Zone Types (optional):</label>
            <select class="event-zone-types" multiple style="width: 100%; height: 80px;">
              <option value="all" selected>All</option>
              <option value="human_facing">Human Facing</option>
              <option value="left">Left</option>
              <option value="right">Right</option>
              <option value="center">Center</option>
              <option value="top">Top</option>
              <option value="bottom">Bottom</option>
            </select>
            <div class="form-tips">Hold Ctrl/Cmd to select multiple zone entry types. 'All' is mutually exclusive with other selections.</div>
          </div>
          <div class="form-row">
            <label>Preferred Places (optional):</label>
            <div class="event-zone-places-container" style="border: 1px solid #ddd; padding: 10px; max-height: 300px; overflow-y: auto;">
              <div class="form-tips" style="margin-bottom: 10px;">Select waypoints from available list. Drag selected waypoints to reorder priority (top = highest priority).</div>
              
              <div style="display: flex; gap: 10px;">
                <!-- Available waypoints -->
                <div style="flex: 1;">
                  <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Available Waypoints</h4>
                  <div class="available-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #fafafa;">
                    <!-- Available waypoints will be populated here -->
                  </div>
                </div>
                
                <!-- Selected waypoints (ordered) -->
                <div style="flex: 1;">
                  <h4 style="margin: 0 0 5px 0; font-size: 12px; color: #666;">Selected Waypoints (Priority Order)</h4>
                  <div class="selected-waypoints" style="border: 1px solid #eee; padding: 5px; min-height: 100px; max-height: 150px; overflow-y: auto; background: #f0f8ff;">
                    <!-- Selected waypoints will be shown here in order -->
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="form-row">
            <label>Final Facing (radians, optional):</label>
            <input type="number" class="event-zone-facing" step="0.01" placeholder="e.g., 1.57 (90 degrees) - applies if no waypoint orientations set" style="width: 100%;">
          </div>
        `);
        
        // Populate zones from RMF data
        const node = TaskV2EventUtils.currentNode;
        if (node && node.rmfData && node.rmfData.zones) {
          console.log('Populating zones, zones:', node.rmfData.zones.length);
          const zoneSelect = detailsDiv.find('.event-zone');
          const placesSelect = detailsDiv.find('.event-zone-places');
          
          // Populate zones
          node.rmfData.zones.forEach(zone => {
            if (zone.name && zone.name.trim() !== '') {
              zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
            }
          });
          
          // Handle zone types selection logic
          const zoneTypesSelect = detailsDiv.find('.event-zone-types');
          let previousSelection = ['all']; // Track previous selection
          
          zoneTypesSelect.on('change', function() {
            const selectedValues = $(this).val() || [];
            const allSelected = selectedValues.includes('all');
            const othersSelected = selectedValues.filter(v => v !== 'all');
            
            if (allSelected && othersSelected.length > 0) {
              // Both 'all' and others are selected, determine which was added
              const wasAllPreviouslySelected = previousSelection.includes('all');
              
              if (!wasAllPreviouslySelected) {
                // 'all' was just selected, unselect all others
                $(this).val(['all']);
                previousSelection = ['all'];
              } else {
                // Another option was just selected, unselect 'all'
                $(this).val(othersSelected);
                previousSelection = othersSelected;
              }
            } else if (selectedValues.length === 0) {
              // If nothing is selected, default to 'all'
              $(this).val(['all']);
              previousSelection = ['all'];
            } else {
              // Valid selection, update previous
              previousSelection = selectedValues.slice();
            }
          });
          
          // Update places when zone changes
          zoneSelect.on('change', function() {
            const selectedZone = $(this).val();
            const availableContainer = detailsDiv.find('.available-waypoints');
            const selectedContainer = detailsDiv.find('.selected-waypoints');
            
            availableContainer.empty();
            selectedContainer.empty();
            
            if (selectedZone) {
              const zone = node.rmfData.zones.find(z => z.name === selectedZone);
              if (zone) {
                console.log('Zone data for', selectedZone, ':', zone);
                
                const zoneVertices = getZoneVertices(zone);
                console.log('Zone vertices:', zoneVertices);
                
                if (zoneVertices.length > 0) {
                  zoneVertices.forEach((vertex, index) => {
                    let vertexName, displayName, vertexValue;
                    
                    // Handle different zone vertex structures
                    if (typeof vertex === 'object' && vertex.name) {
                      // Vertex object with name
                      vertexName = vertex.name;
                      vertexValue = vertex.name;
                      displayName = vertexName;
                    } else if (typeof vertex === 'number') {
                      // Vertex index - find corresponding vertex name from navGraphs
                      const graph = node.rmfData.navGraphs ? node.rmfData.navGraphs.find(g => 
                        g.name === zone.graph || g.vertices.length > vertex
                      ) : null;
                      
                      if (graph && graph.vertices[vertex]) {
                        vertexName = graph.vertices[vertex].name || `Vertex ${vertex}`;
                        vertexValue = vertexName;
                        displayName = `${vertexName} (Position ${index + 1})`;
                      } else {
                        vertexName = `Vertex ${vertex}`;
                        vertexValue = `vertex_${vertex}`;
                        displayName = `Position ${index + 1} (Index ${vertex})`;
                      }
                    } else {
                      // Fallback for other structures
                      vertexName = `Position ${index + 1}`;
                      vertexValue = `vertex_${index}`;
                      displayName = vertexName;
                    }
                    
                    // Create available waypoint item
                    const availableItem = $(`
                      <div class="available-waypoint-item" data-waypoint="${vertexValue}" style="
                        padding: 5px; 
                        margin: 2px 0; 
                        background: white; 
                        border: 1px solid #ddd; 
                        cursor: pointer;
                        border-radius: 3px;
                        font-size: 11px;
                      ">
                        <span style="color: #333;">${displayName}</span>
                      </div>
                    `);
                    
                    availableContainer.append(availableItem);
                    
                    // Handle click to add to selected
                    availableItem.on('click', function() {
                      const waypointValue = $(this).data('waypoint');
                      addToSelectedWaypoints(waypointValue, displayName, selectedContainer, availableContainer);
                    });
                  });
                  
                  // Make selected waypoints sortable (fallback if jQuery UI not available)
                  try {
                    selectedContainer.sortable({
                      items: '.selected-waypoint-item',
                      placeholder: 'waypoint-placeholder',
                      tolerance: 'pointer',
                      cursor: 'move'
                    });
                  } catch (e) {
                    console.log('jQuery UI sortable not available, using basic ordering');
                  }
                }
              }
            }
          });
          
          // Function to add waypoint to selected list
          function addToSelectedWaypoints(waypointValue, displayName, selectedContainer, availableContainer) {
            // Check if already selected
            if (selectedContainer.find(`[data-waypoint="${waypointValue}"]`).length > 0) {
              return;
            }
            
            const selectedItem = $(`
              <div class="selected-waypoint-item" data-waypoint="${waypointValue}" style="
                padding: 5px; 
                margin: 2px 0; 
                background: #e3f2fd; 
                border: 1px solid #1976d2; 
                border-radius: 3px;
                font-size: 11px;
                cursor: move;
                display: flex;
                align-items: center;
                gap: 5px;
              ">
                <span class="drag-handle" style="cursor: ns-resize; color: #666; font-weight: bold;">⋮⋮</span>
                <span style="flex: 1; color: #1565c0;">${displayName}</span>
                <input type="number" class="waypoint-orientation" step="0.01" placeholder="orient." style="width: 50px; font-size: 10px;" title="Orientation in radians">
                <button type="button" class="move-up" style="
                  background: #4caf50; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Move up">↑</button>
                <button type="button" class="move-down" style="
                  background: #ff9800; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Move down">↓</button>
                <button type="button" class="remove-waypoint" style="
                  background: #d32f2f; 
                  color: white; 
                  border: none; 
                  border-radius: 2px; 
                  width: 16px; 
                  height: 16px; 
                  font-size: 10px; 
                  cursor: pointer;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                " title="Remove waypoint">×</button>
              </div>
            `);
            
            selectedContainer.append(selectedItem);
            
            // Hide from available list
            availableContainer.find(`[data-waypoint="${waypointValue}"]`).hide();
            
            // Handle move up button
            selectedItem.find('.move-up').on('click', function(e) {
              e.stopPropagation();
              const prev = selectedItem.prev('.selected-waypoint-item');
              if (prev.length > 0) {
                selectedItem.insertBefore(prev);
              }
            });
            
            // Handle move down button
            selectedItem.find('.move-down').on('click', function(e) {
              e.stopPropagation();
              const next = selectedItem.next('.selected-waypoint-item');
              if (next.length > 0) {
                selectedItem.insertAfter(next);
              }
            });
            
            // Handle remove button
            selectedItem.find('.remove-waypoint').on('click', function(e) {
              e.stopPropagation();
              selectedItem.remove();
              // Show back in available list
              availableContainer.find(`[data-waypoint="${waypointValue}"]`).show();
            });
          }
          
          // Set values from eventData
          if (eventData.zone) {
            zoneSelect.val(eventData.zone);
            zoneSelect.trigger('change'); // Populate places
            console.log('Set zone value to:', eventData.zone, 'Found in dropdown:', zoneSelect.find(`option[value="${eventData.zone}"]`).length > 0);
          }
          if (eventData.types && Array.isArray(eventData.types)) {
            detailsDiv.find('.event-zone-types').val(eventData.types);
          }
          if (eventData.places && Array.isArray(eventData.places)) {
            setTimeout(() => {
              eventData.places.forEach(place => {
                let waypointName, orientation;
                
                if (typeof place === 'string') {
                  waypointName = place;
                  orientation = undefined;
                } else if (place.waypoint) {
                  waypointName = place.waypoint;
                  orientation = place.orientation;
                }
                
                if (waypointName) {
                  const availableContainer = detailsDiv.find('.available-waypoints');
                  const selectedContainer = detailsDiv.find('.selected-waypoints');
                  const availableItem = availableContainer.find(`[data-waypoint="${waypointName}"]`);
                  
                  if (availableItem.length > 0) {
                    // Find the display name from available item
                    const displayName = availableItem.find('span').text();
                    
                    // Add to selected (this will call our function)
                    addToSelectedWaypoints(waypointName, displayName, selectedContainer, availableContainer);
                    
                    // Set orientation if provided
                    if (orientation !== undefined) {
                      const selectedItem = selectedContainer.find(`[data-waypoint="${waypointName}"]`);
                      selectedItem.find('.waypoint-orientation').val(orientation);
                    }
                  }
                }
              });
              console.log('Set zone places from eventData:', eventData.places);
            }, 100);
          }
          if (eventData.facing !== undefined) {
            detailsDiv.find('.event-zone-facing').val(eventData.facing);
          }
        } else {
          console.log('No RMF data available for zones. Node:', !!node, 'rmfData:', node ? !!node.rmfData : 'no node', 'zones:', node && node.rmfData ? node.rmfData.zones?.length : 'no rmfData');
        }
        
      } else if (category === 'perform_action') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Action Category:</label>
            <input type="text" class="event-action-category" value="${eventData.action_category || 'teleop'}" style="width: 100%;">
          </div>
          <div class="form-row">
            <label>Action Description:</label>
            <textarea class="event-action-description" style="width: 100%; height: 60px;">${eventData.action_description || ''}</textarea>
          </div>
          <div class="form-row">
            <label>Duration Estimate (ms):</label>
            <input type="number" class="event-duration-estimate" value="${eventData.duration_estimate || 30000}" style="width: 100%;">
          </div>
        `);
      } else if (category === 'couple') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Number of Robots:</label>
            <input type="number" class="event-couple-robots" min="2" value="${eventData.number_of_robots || 2}" style="width: 100%;">
          </div>
          <div class="form-row">
            <label>Robot Names (comma-separated):</label>
            <input type="text" class="event-couple-robots-list" value="${eventData.robots ? eventData.robots.join(', ') : ''}" style="width: 100%;">
            <div class="form-tips">Optional: Specific robot names. Leave empty for auto-selection from task fleet.</div>
          </div>
          <div class="form-row">
            <label>Expected Zone:</label>
            <select class="event-couple-zone" style="width: 100%;">
              <option value="">Select zone...</option>
            </select>
            <div class="form-tips">Zone where robots are expected to perform coupling</div>
          </div>
          <div class="form-row">
            <label>Estimated Duration (seconds):</label>
            <input type="number" class="event-couple-duration" min="0" value="${eventData.estimated_duration || 300}" style="width: 100%;">
          </div>
        `);
        
        // Populate zones from RMF data
        const node = TaskV2EventUtils.currentNode;
        if (node && node.rmfData && node.rmfData.zones) {
          const zoneSelect = detailsDiv.find('.event-couple-zone');
          node.rmfData.zones.forEach(zone => {
            if (zone.name && zone.name.trim() !== '') {
              zoneSelect.append(`<option value="${zone.name}">${zone.name}</option>`);
            }
          });
          
          // Set saved value if provided
          if (eventData.expected_zone) {
            zoneSelect.val(eventData.expected_zone);
          }
        }
      } else if (category === 'decouple') {
        detailsDiv.html(`
          <div class="form-row">
            <label>Estimated Duration (seconds):</label>
            <input type="number" class="event-decouple-duration" min="0" value="${eventData.estimated_duration || 60}" style="width: 100%;">
            <div class="form-tips">Estimated time to decouple previously coupled robots</div>
          </div>
        `);
      }
    },
    
    getEventsData: function(container) {
      const events = [];
      container.find('.event-item').each(function() {
        const eventDiv = $(this);
        const category = eventDiv.find('.event-category').val();
        const eventData = { category };
        
        if (category === 'go_to_place') {
          const locationName = eventDiv.find('.event-location').val();
          const orientation = eventDiv.find('.event-orientation').val();
          
          if (orientation && orientation.trim() !== '') {
            // Create place object with orientation
            eventData.description = {
              waypoint: locationName,
              orientation: parseFloat(orientation)
            };
          } else {
            // Simple waypoint name
            eventData.description = locationName;
          }
        } else if (category === 'go_to_zone') {
          eventData.zone = eventDiv.find('.event-zone').val();
          
          // Parse zone types
          const selectedTypes = eventDiv.find('.event-zone-types').val();
          if (selectedTypes && selectedTypes.length > 0) {
            eventData.types = selectedTypes;
          }
          
          // Get selected places with orientations (in order)
          const selectedPlaces = [];
          eventDiv.find('.selected-waypoint-item').each(function() {
            const waypointName = $(this).data('waypoint');
            const orientationInput = $(this).find('.waypoint-orientation');
            const orientation = orientationInput.val();
            
            if (orientation && orientation.trim()) {
              // Create place object with waypoint and orientation
              selectedPlaces.push({
                waypoint: waypointName,
                orientation: parseFloat(orientation)
              });
            } else {
              // Create place object with just waypoint
              selectedPlaces.push({ waypoint: waypointName });
            }
          });
          
          if (selectedPlaces.length > 0) {
            eventData.places = selectedPlaces;
          }
          
          // Get facing direction (fallback for overall zone facing)
          const facing = eventDiv.find('.event-zone-facing').val();
          if (facing && facing.trim()) {
            eventData.facing = parseFloat(facing);
          }
        } else if (category === 'perform_action') {
          eventData.action_category = eventDiv.find('.event-action-category').val();
          eventData.action_description = eventDiv.find('.event-action-description').val();
          eventData.duration_estimate = parseInt(eventDiv.find('.event-duration-estimate').val()) || 30000;
        } else if (category === 'couple') {
          eventData.number_of_robots = parseInt(eventDiv.find('.event-couple-robots').val()) || 2;
          const robotsList = eventDiv.find('.event-couple-robots-list').val();
          if (robotsList && robotsList.trim()) {
            eventData.robots = robotsList.split(',').map(r => r.trim()).filter(r => r.length > 0);
          }
          eventData.expected_zone = eventDiv.find('.event-couple-zone').val();
          eventData.estimated_duration = parseInt(eventDiv.find('.event-couple-duration').val()) || 300;
        } else if (category === 'decouple') {
          eventData.estimated_duration = parseInt(eventDiv.find('.event-decouple-duration').val()) || 60;
        }
        
        events.push(eventData);
      });
      return events;
    },
    
    setEventsData: function(container, events) {
      console.log('setEventsData called with events:', events);
      container.empty();
      if (events && events.length > 0) {
        events.forEach(eventData => {
          console.log('Adding event:', eventData);
          TaskV2EventUtils.addEvent(container, eventData);
        });
        
        // Delay to ensure dropdowns are populated before setting values
        setTimeout(() => {
          console.log('Restoring event values after delay');
          TaskV2EventUtils.restoreEventValues(container, events);
        }, 100);
      } else {
        // Add default go_to_place event
        TaskV2EventUtils.addEvent(container, { category: 'go_to_place' });
      }
    },
    
    restoreEventValues: function(container, events) {
      // Restore saved values to event dropdowns after they're populated
      console.log('restoreEventValues called with events:', events);
      container.find('.event-item').each(function(index) {
        const eventDiv = $(this);
        const eventData = events[index];
        console.log(`Restoring event ${index}:`, eventData);
        
        if (eventData && eventData.category) {
          // Set category first
          eventDiv.find('.event-category').val(eventData.category);
          
          // Then restore specific values based on category
          if (eventData.category === 'go_to_place' && eventData.description) {
            const locationSelect = eventDiv.find('.event-location');
            const orientationInput = eventDiv.find('.event-orientation');
            
            if (typeof eventData.description === 'string') {
              // Simple waypoint name
              locationSelect.val(eventData.description);
              orientationInput.val('');
            } else if (eventData.description && eventData.description.waypoint) {
              // Place object with potential orientation
              locationSelect.val(eventData.description.waypoint);
              if (eventData.description.orientation !== undefined) {
                orientationInput.val(eventData.description.orientation);
              } else {
                orientationInput.val('');
              }
            }
            console.log(`Set location to ${eventData.description}, result:`, locationSelect.val());
          } else if (eventData.category === 'go_to_zone') {
            if (eventData.zone) {
              const zoneSelect = eventDiv.find('.event-zone');
              zoneSelect.val(eventData.zone);
              zoneSelect.trigger('change'); // Populate places
              console.log(`Set zone to ${eventData.zone}, result:`, zoneSelect.val());
            }
            if (eventData.types && Array.isArray(eventData.types)) {
              eventDiv.find('.event-zone-types').val(eventData.types);
            }
            if (eventData.places && Array.isArray(eventData.places)) {
              setTimeout(() => {
                eventData.places.forEach(place => {
                  let waypointName, orientation;
                  
                  if (typeof place === 'string') {
                    waypointName = place;
                    orientation = undefined;
                  } else if (place.waypoint) {
                    waypointName = place.waypoint;
                    orientation = place.orientation;
                  } else if (place.name) {
                    // Legacy support for old format
                    waypointName = place.name;
                    orientation = place.orientation;
                  }
                  
                  if (waypointName) {
                    const availableContainer = eventDiv.find('.available-waypoints');
                    const selectedContainer = eventDiv.find('.selected-waypoints');
                    const availableItem = availableContainer.find(`[data-waypoint="${waypointName}"]`);
                    
                    if (availableItem.length > 0) {
                      // Find the display name from available item
                      const displayName = availableItem.find('span').text();
                      
                      // Add to selected (this will call our function)
                      const addToSelectedWaypoints = eventDiv.closest('.event-details').data('addToSelectedWaypoints');
                      if (typeof addToSelectedWaypoints === 'function') {
                        addToSelectedWaypoints(waypointName, displayName, selectedContainer, availableContainer);
                      } else {
                        // Fallback - directly add to selected
                        availableItem.click();
                      }
                      
                      // Set orientation if provided
                      if (orientation !== undefined) {
                        setTimeout(() => {
                          const selectedItem = selectedContainer.find(`[data-waypoint="${waypointName}"]`);
                          selectedItem.find('.waypoint-orientation').val(orientation);
                        }, 10);
                      }
                    }
                  }
                });
                console.log(`Set zone places from saved data:`, eventData.places);
              }, 100);
            }
            if (eventData.facing !== undefined) {
              eventDiv.find('.event-zone-facing').val(eventData.facing);
            }
          } else if (eventData.category === 'perform_action') {
            if (eventData.action_category) {
              eventDiv.find('.event-action-category').val(eventData.action_category);
            }
            if (eventData.action_description) {
              eventDiv.find('.event-action-description').val(eventData.action_description);
            }
            if (eventData.duration_estimate) {
              eventDiv.find('.event-duration-estimate').val(eventData.duration_estimate);
            }
          }
        }
      });
    },
    
    refreshAllEventDropdowns: function(container) {
      // Refresh dropdowns for all existing events when RMF data is updated
      const currentEvents = []; // Store current event data
      
      container.find('.event-item').each(function() {
        const eventDiv = $(this);
        const category = eventDiv.find('.event-category').val();
        const currentData = { category };
        
        // Preserve current values
        if (category === 'go_to_place') {
          const locationName = eventDiv.find('.event-location').val();
          const orientation = eventDiv.find('.event-orientation').val();
          
          if (orientation && orientation.trim() !== '') {
            currentData.description = {
              waypoint: locationName,
              orientation: parseFloat(orientation)
            };
          } else {
            currentData.description = locationName;
          }
        } else if (category === 'go_to_zone') {
          currentData.zone = eventDiv.find('.event-zone').val();
          const selectedTypes = eventDiv.find('.event-zone-types').val();
          if (selectedTypes && selectedTypes.length > 0) {
            currentData.types = selectedTypes;
          }
          const selectedPlaces = [];
          eventDiv.find('.selected-waypoint-item').each(function() {
            const waypointName = $(this).data('waypoint');
            const orientationInput = $(this).find('.waypoint-orientation');
            const orientation = orientationInput.val();
            
            if (orientation && orientation.trim()) {
              selectedPlaces.push({
                waypoint: waypointName,
                orientation: parseFloat(orientation)
              });
            } else {
              selectedPlaces.push({ waypoint: waypointName });
            }
          });
          if (selectedPlaces.length > 0) {
            currentData.places = selectedPlaces;
          }
          const facing = eventDiv.find('.event-zone-facing').val();
          if (facing && facing.trim()) {
            currentData.facing = parseFloat(facing);
          }
        } else if (category === 'perform_action') {
          currentData.action_category = eventDiv.find('.event-action-category').val();
          currentData.action_description = eventDiv.find('.event-action-description').val();
          currentData.duration_estimate = parseInt(eventDiv.find('.event-duration-estimate').val()) || 30000;
        } else if (category === 'couple') {
          currentData.number_of_robots = parseInt(eventDiv.find('.event-couple-robots').val()) || 2;
          const robotsList = eventDiv.find('.event-couple-robots-list').val();
          if (robotsList && robotsList.trim()) {
            currentData.robots = robotsList.split(',').map(r => r.trim()).filter(r => r.length > 0);
          }
          currentData.expected_zone = eventDiv.find('.event-couple-zone').val();
          currentData.estimated_duration = parseInt(eventDiv.find('.event-couple-duration').val()) || 300;
        } else if (category === 'decouple') {
          currentData.estimated_duration = parseInt(eventDiv.find('.event-decouple-duration').val()) || 60;
        }
        
        currentEvents.push(currentData);
        
        // Refresh the event details (this repopulates dropdowns)
        TaskV2EventUtils.updateEventDetails(eventDiv, category, {});
      });
      
      // Restore the values after dropdowns are refreshed
      setTimeout(() => {
        TaskV2EventUtils.restoreEventValues(container, currentEvents);
      }, 100);
    },
    
    getEventData: function(eventDiv) {
      const category = eventDiv.find('.event-category').val();
      const eventData = { category };
      
      if (category === 'go_to_place') {
        eventData.description = eventDiv.find('.event-location').val();
        const orientation = eventDiv.find('.event-orientation').val();
        if (orientation !== '') {
          eventData.orientation = parseFloat(orientation);
        }
      } else if (category === 'go_to_zone') {
        eventData.zone = eventDiv.find('.event-zone').val();
        
        // Get zone types
        const zoneTypes = [];
        eventDiv.find('.event-zone-types option:selected').each(function() {
          zoneTypes.push($(this).val());
        });
        if (zoneTypes.length > 0 && !zoneTypes.includes('all')) {
          eventData.zone_types = zoneTypes;
        }
        
        // Get preferred places
        const places = [];
        eventDiv.find('.selected-waypoints .waypoint-item').each(function() {
          places.push($(this).data('waypoint'));
        });
        if (places.length > 0) {
          eventData.preferred_places = places;
        }
        
        const facing = eventDiv.find('.event-zone-facing').val();
        if (facing !== '') {
          eventData.facing = parseFloat(facing);
        }
      } else if (category === 'perform_action') {
        eventData.action_category = eventDiv.find('.event-action-category').val();
        eventData.action_description = eventDiv.find('.event-action-description').val();
      } else if (category === 'couple' || category === 'decouple') {
        eventData.action_category = category;
        eventData.action_description = eventDiv.find('.event-action-description').val() || `${category} action`;
      }
      
      return eventData;
    }
  };

  // RMF Form Utilities specific to TaskV2
  const TaskV2RMFUtils = {
    populateRobotDropdown: function(options = {}) {
      const { node, selectId = 'node-input-robot_name', placeholder = 'Use msg.rmf_robot_name', valueProperty = 'robot_name' } = options;
      const select = $(`#${selectId}`);
      const currentValue = node.isLoaded ? select.val() : node[valueProperty];
      
      select.empty().append(`<option value="">${placeholder}</option>`);
      
      if (node.rmfData && node.rmfData.robots && node.rmfData.robots.length > 0) {
        node.rmfData.robots.forEach(robot => {
          select.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
        });
      }
      
      select.val(currentValue || '');
    },

    populateFleetDropdown: function(options = {}) {
      const { node, selectId = 'node-input-robot_fleet', placeholder = 'Use msg.rmf_robot_fleet', valueProperty = 'robot_fleet' } = options;
      const select = $(`#${selectId}`);
      const currentValue = node.isLoaded ? select.val() : node[valueProperty];
      
      select.empty().append(`<option value="">${placeholder}</option>`);
      
      if (node.rmfData && node.rmfData.fleets && node.rmfData.fleets.length > 0) {
        node.rmfData.fleets.forEach(fleet => {
          select.append(`<option value="${fleet}">${fleet}</option>`);
        });
      }
      
      select.val(currentValue || '');
    },

    setupRobotFleetHandlers: function(options = {}) {
      const { node, robotSelectId = 'node-input-robot_name', fleetSelectId = 'node-input-robot_fleet' } = options;
      const robotSelect = $(`#${robotSelectId}`);
      const fleetSelect = $(`#${fleetSelectId}`);

      robotSelect.off('change').on('change', function() {
        const selectedRobot = $(this).val();
        const selectedOption = $(this).find('option:selected');
        const robotFleet = selectedOption.data('fleet');
        
        if (selectedRobot && selectedRobot !== '' && robotFleet) {
          fleetSelect.val(robotFleet);
        } else {
          fleetSelect.val('');
        }
      });

      fleetSelect.off('change').on('change', function() {
        const selectedFleet = $(this).val();
        const currentRobot = robotSelect.val();
        
        if (currentRobot && selectedFleet && node.rmfData && node.rmfData.robots) {
          const robot = node.rmfData.robots.find(r => r.name === currentRobot);
          if (robot && robot.fleet !== selectedFleet) {
            robotSelect.val('');
          }
        }
        
        if (selectedFleet && selectedFleet !== '') {
          robotSelect.empty().append('<option value="">Use msg.rmf_robot_name</option>');
          if (node.rmfData && node.rmfData.robots) {
            node.rmfData.robots.forEach(robot => {
              if (robot.fleet === selectedFleet) {
                robotSelect.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
              }
            });
          }
          const robotFromFleet = node.rmfData.robots ? node.rmfData.robots.find(r => r.name === currentRobot && r.fleet === selectedFleet) : null;
          if (robotFromFleet) {
            robotSelect.val(currentRobot);
          }
        } else {
          robotSelect.empty().append('<option value="">Use msg.rmf_robot_name</option>');
          if (node.rmfData && node.rmfData.robots) {
            node.rmfData.robots.forEach(robot => {
              robotSelect.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
            });
          }
          robotSelect.val(currentRobot);
        }
      });
    },

    showDataStatus: function(message, type = 'info', configSelectId = 'node-input-config') {
      $('.rmf-data-status').remove();
      let color = '#2196f3', icon = 'fa-info-circle';
      if (type === 'error') { color = '#f44336'; icon = 'fa-exclamation-triangle'; }
      else if (type === 'success') { color = '#4caf50'; icon = 'fa-check-circle'; }
      const statusDiv = $(`<div class="rmf-data-status form-tips" style="color: ${color}; margin-top: 10px;"><i class="fa ${icon}" style="margin-right: 5px;"></i>${message}</div>`);
      $(`#${configSelectId}`).closest('.form-row').after(statusDiv);
    }
  };

  // Helper functions
  function getZoneVertices(zone) {
    return zone.vertices || zone.zone_vertices || [];
  }
  
  function getVertexLevel(vertex) {
    if (vertex.params && vertex.params.length > 0) {
      const mapNameParam = vertex.params.find(p => p.name === 'map_name');
      if (mapNameParam && mapNameParam.value_string) {
        return mapNameParam.value_string;
      }
    }
    return 'L1'; // Default level
  }

  RED.nodes.registerType('start-taskV2', {
    category: 'RMF v1 (OLD)',
    color: '#87CEEB',
    defaults: {
      name: { value: '' },
      config: { type: 'rmf-config', required: true },
      robot_name: { value: '' },
      robot_fleet: { value: '' },
      task_type: { value: 'compose' },
      task_data: { value: { phases: [] } }
    },
    inputs: 1,
    outputs: 3,
    outputLabels: ["success", "failed", "status"],
    icon: 'rmf.svg',
    label: function () {
      return this.name || 'Create Task';
    },
    paletteLabel: 'Create Task',
    oneditprepare: function() {
      const node = this;
      node.isLoaded = true;
      
      // Set the current node reference
      TaskV2Utils.setCurrentNode(node);
      TaskV2EventUtils.setCurrentNode(node);
      
      console.log('Node oneditprepare - saved task_data:', node.task_data);
      
      // Initialize data storage (same structure as goto-place)
      node.rmfData = {
        robots: [],
        fleets: [],
        navGraphs: [],
        zones: []
      };
      
      // Load RMF data
      loadRMFData();
      
      // Setup change handlers
      setupChangeHandlers();
      
      // Setup refresh button
      setupRefreshButton();
      
      // Setup task management
      setupTaskManagement();
      
      function loadRMFData() {
        $.getJSON('/rmf/data', function(data) {
          node.rmfData = data;
          
          if (data.status === 'not_initialized') {
            TaskV2RMFUtils.showDataStatus('RMF not initialized. Deploy RMF Config node first.', 'info');
          } else if (data.status === 'error') {
            TaskV2RMFUtils.showDataStatus('Error loading RMF data: ' + data.message, 'error');
          } else if (data.robots.length === 0) {
            TaskV2RMFUtils.showDataStatus('No RMF data available. Check RMF system status.', 'info');
          } else {
            const locationCount = (data.navGraphs || []).reduce((count, ng) => count + (ng.vertices || []).length, 0);
            const zoneCount = (data.zones || []).length;
            TaskV2RMFUtils.showDataStatus(`Loaded ${data.robots.length} robots, ${locationCount} locations, ${zoneCount} zones`, 'success');
          }
          
          // Populate dropdowns
          TaskV2RMFUtils.populateRobotDropdown({ node });
          TaskV2RMFUtils.populateFleetDropdown({ node });
          
          // Update task configuration with new data
          const taskType = $('#node-input-task_type').val();
          const container = $('#task-config-container');
          TaskV2Utils.setupTaskType(container, taskType, node.task_data);
        }).fail(function(xhr, status, error) {
          console.error('Failed to load RMF data:', error);
          node.rmfData = { robots: [], fleets: [], navGraphs: [], zones: [] };
          node.rmfDataLoaded = true;
          
          TaskV2RMFUtils.populateRobotDropdown({ node });
          TaskV2RMFUtils.populateFleetDropdown({ node });
        });
      }
      
      function setupRefreshButton() {
        $('#refresh-rmf-data').on('click', function() {
          const button = $(this);
          const originalText = button.html();
          
          button.html('<i class="fa fa-spinner fa-spin"></i> Loading...');
          button.prop('disabled', true);
          
          loadRMFData();
          
          setTimeout(() => {
            button.html(originalText);
            button.prop('disabled', false);
          }, 1000);
        });
      }
      
      function setupChangeHandlers() {
        TaskV2RMFUtils.setupRobotFleetHandlers({ node });
        
        // Task type change handler
        $('#node-input-task_type').on('change', function() {
          const taskType = $(this).val();
          const container = $('#task-config-container');
          TaskV2Utils.setupTaskType(container, taskType, {});
        });
      }
      
      function setupTaskManagement() {
        // Initialize task configuration based on current type
        const taskType = $('#node-input-task_type').val() || node.task_type || 'compose';
        $('#node-input-task_type').val(taskType);
        
        const container = $('#task-config-container');
        TaskV2Utils.setupTaskType(container, taskType, node.task_data);
      }
    },
    
    oneditsave: function() {
      // Save task data
      this.task_data = TaskV2Utils.getTaskData($('#task-config-container'));
    }
  });
</script>

<script type="text/html" data-template-name="start-taskV2">
  <div class="form-row">
    <label for="node-input-name">Name</label>
    <input type="text" id="node-input-name">
  </div>
  
  <div class="form-row">
    <label for="node-input-config"><i class="fa fa-cogs"></i> RMF Config</label>
    <input type="text" id="node-input-config" style="width: 60%;">
    <button type="button" id="refresh-rmf-data" class="red-ui-button" style="margin-left: 10px; width: auto;">
      <i class="fa fa-refresh"></i> Refresh Data
    </button>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_name">Robot Name</label>
    <select id="node-input-robot_name" style="width: 100%;">
      <option value="">Use msg.rmf_robot_name (dispatch)</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_fleet">Robot Fleet</label>
    <select id="node-input-robot_fleet" style="width: 100%;">
      <option value="">Use msg.rmf_robot_fleet (dispatch)</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-task_type">Task Type</label>
    <select id="node-input-task_type" style="width: 100%;">
      <option value="compose">Compose</option>
      <option value="patrol">Patrol</option>
      <option value="zone">Zone</option>
      <option value="couple">Couple</option>
      <option value="decouple">Decouple</option>
    </select>
  </div>
  
  <div id="task-config-container">
    <!-- Task-specific configuration will be dynamically added here -->
  </div>
  
  <div class="form-tips">
    <b>RMF Task V2:</b><br/>
    Creates RMF tasks with different types and structures.<br/><br/>
    
    <b>Task Types:</b><br/>
    • <b>Compose:</b> Custom tasks with phases containing sequential events<br/>
    • <b>Patrol:</b> Patrol between multiple places for specified rounds<br/>
    • <b>Zone:</b> Navigate to a specific zone<br/>
    • <b>Couple:</b> Coordinate multiple robots to couple at a zone<br/>
    • <b>Decouple:</b> Separate coupled robots at a zone<br/><br/>
    
    <b>Robot Assignment:</b><br/>
    • Specify robot name + fleet for dedicated assignment<br/>
    • Leave empty for automatic dispatch to any available robot
  </div>
</script>

<script type="text/html" data-help-name="start-taskV2">
  <p>Creates RMF Task V2 requests with support for different task types including compose, patrol, zone, couple, and decouple tasks.</p>
  
  <h3>Configuration</h3>
  <dl class="message-properties">
    <dt>Robot Name <span class="property-type">string</span></dt>
    <dd>Target robot name (optional for dispatch). Select from dropdown or use "Use msg.rmf_robot_name".</dd>
    
    <dt>Robot Fleet <span class="property-type">string</span></dt>
    <dd>Target robot fleet (optional for dispatch). Auto-selected when robot is chosen.</dd>
    
    <dt>Task Type <span class="property-type">string</span></dt>
    <dd>Type of task to create: compose, patrol, zone, couple, or decouple.</dd>
  </dl>
  
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>msg.rmf_robot_name <span class="property-type">string</span></dt>
    <dd>Robot name (overrides config)</dd>
    
    <dt>msg.rmf_robot_fleet <span class="property-type">string</span></dt>
    <dd>Robot fleet (overrides config)</dd>
    
    <dt>msg.task_type <span class="property-type">string</span></dt>
    <dd>Task type (overrides config)</dd>
    
    <dt>msg.task_data <span class="property-type">object</span></dt>
    <dd>Task-specific data (overrides config)</dd>
  </dl>
  
  <h3>Outputs</h3>
  <ol class="node-ports">
    <li>Success
      <dl class="message-properties">
        <dt>payload.status <span class="property-type">string</span></dt>
        <dd>"completed" when task finishes successfully</dd>
        <dt>payload.task_id <span class="property-type">string</span></dt>
        <dd>The RMF task ID</dd>
        <dt>payload.robot_name <span class="property-type">string</span></dt>
        <dd>Assigned robot name</dd>
        <dt>payload.robot_fleet <span class="property-type">string</span></dt>
        <dd>Assigned robot fleet</dd>
        <dt>payload.final_status <span class="property-type">string</span></dt>
        <dd>Final task status from RMF</dd>
      </dl>
    </li>
    <li>Failed
      <dl class="message-properties">
        <dt>payload.status <span class="property-type">string</span></dt>
        <dd>"failed", "cancelled", "waiting", or "error"</dd>
        <dt>payload.reason <span class="property-type">string</span></dt>
        <dd>Description of the failure</dd>
        <dt>payload.task_id <span class="property-type">string</span></dt>
        <dd>The RMF task ID (if created)</dd>
      </dl>
    </li>
    <li>Status
      <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Raw status data from RMF task manager (varies by update type)</dd>
        <dt>topic <span class="property-type">string</span></dt>
        <dd>Message topic: "task/{task_id}/status", "task/{task_id}/feedback", or "task/{task_id}/complete"</dd>
        <dt>timestamp <span class="property-type">string</span></dt>
        <dd>ISO timestamp when the status update was received</dd>
      </dl>
      <p><strong>Status Update Types:</strong></p>
      <ul>
        <li><strong>Task Status:</strong> Direct RMF task state updates with complete task information</li>
        <li><strong>Goal Feedback:</strong> Progress updates during task execution (progress, current_phase, etc.)</li>
        <li><strong>Goal Complete:</strong> Final completion data with execution time and results</li>
      </ul>
    </li>
  </ol>
  
  <h3>Task Types</h3>
  <ul>
    <li><strong>Compose:</strong> Multi-phase tasks with custom event sequences</li>
    <li><strong>Patrol:</strong> Navigate between multiple places for specified rounds</li>
    <li><strong>Zone:</strong> Navigate to a specific zone</li>
    <li><strong>Couple:</strong> Coordinate multiple robots to couple at a zone</li>
    <li><strong>Decouple:</strong> Separate coupled robots at a zone</li>
  </ul>
</script>
