<script type="text/javascript">
  RED.nodes.registerType('goto-place', {
    category: 'RMF Dynamic Event Task',
    color: '#f7c74f',
    defaults: {
      name: { value: '' },
      config: { type: 'rmf-config', required: true },
      robot_name: { value: '' },
      robot_fleet: { value: '' },
      location_name: { value: '' },
      zone_type: { value: 'all' },
      zone_preferred_waypoint: { value: '' },
      stubborn_period: { value: 0 },
      parallel_behaviour: { value: 'abort' }
    },
    inputs: 1,
    outputs: 3,
    outputLabels: ["success", "failed", "status"],
    icon: 'font-awesome/fa-location-arrow',
    label: function () {
      return this.name || 'goto-place';
    },
    oneditprepare: function() {
      const node = this;
      
      // Single source of truth for data
      node.rmfData = { robots: [], locations: [], zones: [], fleets: [], navGraphs: [] };
      
      // Simple state tracking
      node.isLoaded = false;
      
      // Constants
      const PLACEMENT_LABELS = {
        'all': 'All',
        'center': 'Center',
        'left': 'Left', 
        'right': 'Right',
        'top': 'Top',
        'bottom': 'Bottom',
        'patient_facing': 'Patient Facing'
      };
      
      // Mapping from waypoint placement to zone type
      const PLACEMENT_TO_ZONE_TYPE = {
        'left': 'left',
        'right': 'right',
        'center': 'center',
        'forward': 'top',
        'backward': 'bottom'
      };
      
      // Initialize
      init();
      
      function init() {
        loadRMFData().then(() => {
          populateAllDropdowns();
          setupEventHandlers();
          node.isLoaded = true;
        });
      }
      
      // SIMPLIFIED: Single data loading function
      function loadRMFData() {
        return $.getJSON('/rmf/data')
          .done(data => {
            console.log('Received RMF data:', data);
            node.rmfData = data;
            showStatus(data);
          })
          .fail(() => {
            console.error('Failed to load RMF data');
            node.rmfData = { robots: [], locations: [], zones: [], fleets: [], navGraphs: [] };
            showStatus({ status: 'error', message: 'Failed to load RMF data' });
          });
      }
      
      // SIMPLIFIED: Single dropdown population function
      function populateAllDropdowns() {
        populateRobotDropdown();
        populateFleetDropdown();
        populateLevelDropdown();
        populateLocationDropdown();
        updateZoneFields();
      }
      
      // SIMPLIFIED: Individual dropdown functions without complex state logic
      function populateRobotDropdown() {
        const select = $('#node-input-robot_name');
        const currentValue = node.isLoaded ? select.val() : node.robot_name;
        
        select.empty().append('<option value="">Use msg.rmf_robot_name</option>');
        
        if (node.rmfData.robots && node.rmfData.robots.length > 0) {
          node.rmfData.robots.forEach(robot => {
            select.append(`<option value="${robot.name}" data-fleet="${robot.fleet}">${robot.name} (${robot.fleet})</option>`);
          });
        }
        
        select.val(currentValue || '');
      }
      
      function populateFleetDropdown() {
        const select = $('#node-input-robot_fleet');
        const currentValue = node.isLoaded ? select.val() : node.robot_fleet;
        
        select.empty().append('<option value="">Use msg.rmf_robot_fleet</option>');
        
        if (node.rmfData.fleets && node.rmfData.fleets.length > 0) {
          node.rmfData.fleets.forEach(fleet => {
            select.append(`<option value="${fleet}">${fleet}</option>`);
          });
        }
        
        select.val(currentValue || '');
      }
      
      function populateLevelDropdown() {
        const select = $('#node-input-location_level');
        if (select.length === 0) return; // Level dropdown might not exist
        
        const currentValue = node.isLoaded ? select.val() : node.location_level;
        
        select.empty().append('<option value="">All Levels</option>');
        
        // Extract unique levels from locations and zones
        const levels = new Set();
        
        if (node.rmfData.navGraphs) {
          node.rmfData.navGraphs.forEach(navGraph => {
            if (navGraph.vertices) {
              navGraph.vertices.forEach(vertex => {
                const level = getVertexLevel(vertex);
                if (level) levels.add(level);
              });
            }
          });
        }
        
        if (node.rmfData.zones) {
          node.rmfData.zones.forEach(zone => {
            if (zone.level) levels.add(zone.level);
          });
        }
        
        Array.from(levels).sort().forEach(level => {
          select.append(`<option value="${level}">${level}</option>`);
        });
        
        select.val(currentValue || '');
      }
      
      function populateLocationDropdown() {
        const select = $('#node-input-location_name');
        const levelSelect = $('#node-input-location_level');
        const fleetSelect = $('#node-input-robot_fleet');
        
        const currentValue = node.isLoaded ? select.val() : node.location_name;
        const selectedLevel = levelSelect.length > 0 ? levelSelect.val() : '';
        const selectedFleet = fleetSelect.val();
        
        console.log('Populating locations - Fleet:', selectedFleet, 'Level:', selectedLevel);
        
        select.empty().append('<option value="">Use msg.location_name</option>');
        
        // Get relevant nav graphs (filter by fleet if specified)
        let relevantNavGraphs = node.rmfData.navGraphs || [];
        if (selectedFleet) {
          relevantNavGraphs = relevantNavGraphs.filter(ng => 
            ng.fleet === selectedFleet || ng.name === selectedFleet
          );
          console.log('Filtered navGraphs for fleet', selectedFleet, ':', relevantNavGraphs.length);
        }
        
        // Extract locations from nav graphs
        const locations = new Map(); // Use Map to avoid duplicates while keeping metadata
        
        relevantNavGraphs.forEach(navGraph => {
          if (navGraph.vertices) {
            navGraph.vertices.forEach(vertex => {
              if (vertex.name && vertex.name.trim() !== '') {
                const vertexLevel = getVertexLevel(vertex);
                if (!selectedLevel || vertexLevel === selectedLevel) {
                  // Check if this vertex is part of a zone
                  const isPartOfZone = node.rmfData.zones && node.rmfData.zones.some(zone => {
                    const zoneVertices = getZoneVertices(zone);
                    if (zoneVertices.length === 0) return false;
                    
                    // Check different possible zone vertex structures
                    const found = zoneVertices.some(zv => {
                      // Check by name if available
                      if (zv.name && zv.name === vertex.name) return true;
                      
                      // Check by vertex index if zone vertices are indices
                      if (typeof zv === 'number' && vertex.index === zv) return true;
                      
                      // Check if zone vertex has same coordinates as this vertex
                      if (zv.x !== undefined && zv.y !== undefined && 
                          Math.abs(zv.x - vertex.x) < 0.01 && Math.abs(zv.y - vertex.y) < 0.01) {
                        return true;
                      }
                      
                      return false;
                    });
                    
                    if (found) {
                      console.log(`Vertex ${vertex.name} is part of zone ${zone.name}`);
                    }
                    return found;
                  });
                  
                  if (!isPartOfZone) {
                    locations.set(vertex.name, {
                      name: vertex.name,
                      level: vertexLevel,
                      isZone: false
                    });
                  }
                }
              }
            });
          }
        });
        
        // Add zones (only if fleet matches or no fleet filter)
        if (node.rmfData.zones) {
          node.rmfData.zones.forEach(zone => {
            if (zone.name && zone.name.trim() !== '') {
              const zoneLevel = zone.level || 'L1';
              if (!selectedLevel || zoneLevel === selectedLevel) {
                // Check if zone belongs to selected fleet
                let zoneMatchesFleet = true;
                if (selectedFleet) {
                  if (zone.fleets) {
                    // New multi-fleet format
                    zoneMatchesFleet = zone.fleets.includes(selectedFleet);
                  } else if (zone.fleet) {
                    // Legacy single fleet format
                    zoneMatchesFleet = zone.fleet === selectedFleet;
                  }
                }
                
                if (zoneMatchesFleet) {
                  locations.set(zone.name, {
                    name: zone.name,
                    level: zoneLevel,
                    isZone: true
                  });
                }
              }
            }
          });
        }
        
        // Populate dropdown
        Array.from(locations.values()).sort((a, b) => a.name.localeCompare(b.name)).forEach(loc => {
          const type = loc.isZone ? ' (Zone)' : '';
          select.append(`<option value="${loc.name}" data-is-zone="${loc.isZone}">${loc.name}${type}</option>`);
        });
        
        select.val(currentValue || '');
        console.log('Populated', locations.size, 'locations');
      }
      
      // SIMPLIFIED: Event handlers with clear responsibilities
      function setupEventHandlers() {
        // Robot selection: auto-select fleet, refresh locations
        $('#node-input-robot_name').off('change').on('change', function() {
          const robotName = $(this).val();
          if (robotName) {
            const robot = node.rmfData.robots.find(r => r.name === robotName);
            if (robot) {
              $('#node-input-robot_fleet').val(robot.fleet);
              populateLocationDropdown();
            }
          } else {
            $('#node-input-robot_fleet').val('');
            // Don't refresh locations when "Use msg..." is selected to avoid flickering
          }
          updateZoneFields();
        });
        
        // Fleet selection: validate robot, refresh locations
        $('#node-input-robot_fleet').off('change').on('change', function() {
          const fleetName = $(this).val();
          const robotName = $('#node-input-robot_name').val();
          
          console.log('Fleet changed to:', fleetName || '(Use msg)');
          
          // If robot doesn't belong to selected fleet, clear it
          if (robotName && fleetName) {
            const robot = node.rmfData.robots.find(r => r.name === robotName);
            if (robot && robot.fleet !== fleetName) {
              $('#node-input-robot_name').val('');
            }
          }
          
          populateLocationDropdown();
          updateZoneFields();
        });
        
        // Location selection: update zone fields
        $('#node-input-location_name').off('change').on('change', function() {
          updateZoneFields();
        });
        
        // Level selection: refresh locations
        $('#node-input-location_level').off('change').on('change', function() {
          populateLocationDropdown();
          updateZoneFields();
        });
        
        // Refresh button
        $('#refresh-rmf-data').off('click').on('click', function() {
          const button = $(this);
          button.prop('disabled', true).text('Refreshing...');
          
          loadRMFData().then(() => {
            populateAllDropdowns();
            button.prop('disabled', false).html('<i class="fa fa-refresh"></i> Refresh Data');
          });
        });
      }
      
      // SIMPLIFIED: Zone field management
      function updateZoneFields() {
        const locationName = $('#node-input-location_name').val();
        const selectedOption = $('#node-input-location_name option:selected');
        const isZone = selectedOption.data('is-zone') === true;
        
        const zoneTypeRow = $('#node-input-zone_type').closest('.form-row');
        const zoneWaypointRow = $('#node-input-zone_preferred_waypoint').closest('.form-row');
        
        if (isZone && locationName) {
          zoneTypeRow.show();
          zoneWaypointRow.show();
          populateZoneTypeDropdown(locationName);
          populateZoneWaypointDropdown(locationName);
        } else {
          zoneTypeRow.hide();
          zoneWaypointRow.hide();
          $('#node-input-zone_type').val('all');
          $('#node-input-zone_preferred_waypoint').val('');
        }
      }
      
      function populateZoneTypeDropdown(zoneName) {
        const select = $('#node-input-zone_type');
        const currentValue = select.val();
        
        select.empty();
        
        // Find the zone data
        const zone = node.rmfData.zones ? node.rmfData.zones.find(z => z.name === zoneName) : null;
        
        if (zone) {
          const zoneVertices = getZoneVertices(zone);
          
          // Extract placement types from zone vertices and map to zone types
          const placementBasedTypes = [];
          zoneVertices.forEach(vertex => {
            if (vertex.placement) {
              // Map waypoint placement to zone type
              const zoneType = PLACEMENT_TO_ZONE_TYPE[vertex.placement] || vertex.placement;
              if (zoneType && zoneType !== 'default') {
                placementBasedTypes.push(zoneType);
              }
            }
          });
          
          // Remove duplicates from placement-based types
          const uniquePlacementTypes = [...new Set(placementBasedTypes)];
          
          // Add special zone types that are not placement-based
          const specialZoneTypes = ['patient_facing'];
          
          // Combine placement-based types with special types, avoiding duplicates
          const allAvailableTypes = [...uniquePlacementTypes];
          specialZoneTypes.forEach(specialType => {
            if (!allAvailableTypes.includes(specialType)) {
              allAvailableTypes.push(specialType);
            }
          });
          
          // Always add "All" option first
          select.append('<option value="all">All</option>');
          
          // Add placement and special options
          allAvailableTypes.forEach(zoneType => {
            const label = PLACEMENT_LABELS[zoneType] || zoneType;
            select.append(`<option value="${zoneType}">${label}</option>`);
          });
          
          // If no types found, add fallback options
          if (allAvailableTypes.length === 0) {
            select.append('<option value="center">Center</option>');
            select.append('<option value="left">Left</option>');
            select.append('<option value="right">Right</option>');
          }
        } else {
          // Fallback zone types when no zone data available
          select.append('<option value="all">All</option>');
          select.append('<option value="center">Center</option>');
          select.append('<option value="left">Left</option>');
          select.append('<option value="right">Right</option>');
          select.append('<option value="top">Top</option>');
          select.append('<option value="bottom">Bottom</option>');
          select.append('<option value="patient_facing">Patient Facing</option>');
        }
        
        // Restore previous value
        select.val(currentValue || node.zone_type || 'all');
      }
      
      function populateZoneWaypointDropdown(zoneName) {
        const select = $('#node-input-zone_preferred_waypoint');
        const currentValue = select.val();
        
        select.empty().append('<option value="">None</option>');
        
        // Find the zone data
        const zone = node.rmfData.zones ? node.rmfData.zones.find(z => z.name === zoneName) : null;
        
        if (zone) {
          console.log('Zone data for', zoneName, ':', zone);
          
          const zoneVertices = getZoneVertices(zone);
          console.log('Zone vertices:', zoneVertices);
          
          if (zoneVertices.length > 0) {
            zoneVertices.forEach((vertex, index) => {
              let vertexName, displayName, vertexValue;
              
              // Handle different zone vertex structures
              if (typeof vertex === 'object' && vertex.name) {
                // Vertex object with name
                vertexName = vertex.name;
                vertexValue = vertex.name;
                displayName = vertexName;
                
                // Don't add placement info - just use the vertex name
              } else if (typeof vertex === 'number') {
                // Vertex index - find corresponding vertex name from navGraphs
                const graph = node.rmfData.navGraphs ? node.rmfData.navGraphs.find(g => 
                  g.name === zone.graph || g.vertices.length > vertex
                ) : null;
                
                if (graph && graph.vertices[vertex]) {
                  vertexName = graph.vertices[vertex].name || `Vertex ${vertex}`;
                  vertexValue = vertexName;
                  displayName = `${vertexName} (Position ${index + 1})`;
                } else {
                  vertexName = `Vertex ${vertex}`;
                  vertexValue = `vertex_${vertex}`;
                  displayName = `Position ${index + 1} (Index ${vertex})`;
                }
              } else {
                // Fallback for other structures
                vertexName = `Position ${index + 1}`;
                vertexValue = `vertex_${index}`;
                displayName = vertexName;
              }
              
              select.append(`<option value="${vertexValue}">${displayName}</option>`);
            });
          }
        }
        
        // Restore previous value
        select.val(currentValue || node.zone_preferred_waypoint || '');
      }
      
      // Helper functions
      function getZoneVertices(zone) {
        return zone.vertices || zone.zone_vertices || [];
      }
      
      function getVertexLevel(vertex) {
        if (vertex.params && vertex.params.length > 0) {
          const mapNameParam = vertex.params.find(p => p.name === 'map_name');
          if (mapNameParam && mapNameParam.value_string) {
            return mapNameParam.value_string;
          }
        }
        return 'L1'; // Default level
      }
      
      function showStatus(data) {
        // Remove any existing status message
        $('.rmf-data-status').remove();
        
        let message = '';
        let type = 'info';
        
        if (data.status === 'not_initialized') {
          message = 'RMF not initialized. Deploy RMF Config node first.';
          type = 'warning';
        } else if (data.status === 'error') {
          message = 'Error loading RMF data: ' + (data.message || 'Unknown error');
          type = 'error';
        } else if ((data.robots?.length || 0) === 0 && (data.locations?.length || 0) === 0) {
          message = 'No RMF data available. Check RMF system status.';
          type = 'warning';
        } else {
          const robotCount = data.robots?.length || 0;
          const locationCount = data.locations?.length || 0;
          const zoneCount = data.zones?.length || 0;
          const navGraphCount = data.navGraphs?.length || 0;
          message = `Loaded ${robotCount} robots, ${locationCount} locations, ${zoneCount} zones, ${navGraphCount} navGraphs`;
          type = 'success';
        }
        
        const statusColors = {
          'success': '#5cb85c',
          'warning': '#f0ad4e', 
          'error': '#d9534f',
          'info': '#5bc0de'
        };
        
        const statusHtml = `
          <div class="rmf-data-status" style="
            margin: 10px 0; 
            padding: 8px 12px; 
            border-radius: 4px; 
            background-color: ${statusColors[type]}20; 
            border-left: 4px solid ${statusColors[type]}; 
            font-size: 12px;
            color: #333;
          ">
            <i class="fa fa-${type === 'success' ? 'check' : type === 'warning' ? 'exclamation-triangle' : type === 'error' ? 'times' : 'info'}-circle" style="color: ${statusColors[type]}; margin-right: 6px;"></i>
            ${message}
          </div>
        `;
        
        $('#refresh-rmf-data').parent().after(statusHtml);
      }
    },
    oneditsave: function() {
      // Validation
      const locationValue = $('#node-input-location_name').val();
      
      if (!locationValue) {
        RED.notify('Location is required (select a location or use "Use msg.location_name")', 'error');
        return false;
      }
      
      return true;
    }
  });
</script>

<script type="text/html" data-template-name="goto-place">
  <div class="form-row">
    <label for="node-input-name">Name</label>
    <input type="text" id="node-input-name">
  </div>
  <div class="form-row">
    <label for="node-input-config"><i class="fa fa-cogs"></i> RMF Config</label>
    <input type="text" id="node-input-config" style="width: 60%;">
    <button type="button" id="refresh-rmf-data" class="red-ui-button" style="margin-left: 10px; width: auto;">
      <i class="fa fa-refresh"></i> Refresh Data
    </button>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_name">Robot Name</label>
    <select id="node-input-robot_name" style="width: 100%;">
      <option value="">Use msg.rmf_robot_name</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-robot_fleet">Robot Fleet</label>
    <select id="node-input-robot_fleet" style="width: 100%;">
      <option value="">Use msg.rmf_robot_fleet</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-location_name">Location Name <span style="color: red;">*</span></label>
    <select id="node-input-location_name" style="width: 100%;">
      <option value="">Use msg.location_name</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-zone_type">Zone Type </label>
    <select id="node-input-zone_type" style="width: 100%;">
      <option value="all">All</option>
      <option value="left">Left</option>
      <option value="right">Right</option>
      <option value="center">Center</option>
      <option value="top">Top</option>
      <option value="bottom">Bottom</option>
      <option value="patient_facing">Patient Facing</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-zone_preferred_waypoint">Zone Preferred Waypoint</label>
    <select id="node-input-zone_preferred_waypoint" style="width: 100%;">
      <option value="">None</option>
    </select>
  </div>
  
  <div class="form-row">
    <label for="node-input-stubborn_period">Stubborn Period (seconds)</label>
    <input type="number" id="node-input-stubborn_period" min="0" step="0.1" style="width: 100%;">
  </div>
  
  <div class="form-row">
    <label for="node-input-parallel_behaviour">Parallel Behaviour</label>
    <select id="node-input-parallel_behaviour" style="width: 100%;">
      <option value="abort">Abort</option>
      <option value="overwrite">Overwrite</option>
    </select>
  </div>
  
  <div class="form-tips">
    <b>Purpose:</b><br/>
    Sends a robot to a specific location using dynamic events. This node should be connected after a start-task node.<br/><br/>
    
    <b>Setup Requirements:</b><br/>
    • Connect this node after a start-task node<br/>
    • Deploy and connect an RMF Config node first<br/>
    • Refresh data to populate dropdowns<br/><br/>
    
    <b>Configuration Options:</b><br/>
    <dt>Robot Name</dt>
    <dd>The name of the robot to command (optional). Auto-populates fleet when selected, or use "Use msg.rmf_robot_name" to pass via message. Usually passed from start-task node.</dd>
    
    <dt>Robot Fleet</dt>
    <dd>The fleet the robot belongs to (optional). Auto-selected when robot is chosen, or use "Use msg.rmf_robot_fleet" to pass via message. Usually passed from start-task node.</dd>
    
    <dt>Location Name</dt>
    <dd>The destination location or zone name. Locations from nav graphs and zones are shown. Use "Use msg.location_name" to pass via message.</dd>
    
    <dt>Zone Type</dt>
    <dd>For zone locations, specifies the placement within the zone (All, Left, Right, Center, Top, Bottom, Patient Facing, etc.). Only visible when a zone is selected.</dd>
    
    <dt>Zone Preferred Waypoint</dt>
    <dd>For zone locations, allows selection of a specific waypoint within the zone. Only visible when a zone is selected. Use "None" to let the system choose based on zone type.</dd>
    
    <dt>Stubborn Period</dt>
    <dd>Time in seconds that the robot will attempt to reach the location before giving up (default: 0 = no limit).</dd>
    
    <dt>Parallel Behaviour</dt>
    <dd>How to handle overlapping goto requests: "abort" cancels previous request, "overwrite" replaces it.</dd>
  </div>
</script>

<script type="text/html" data-help-name="goto-place">
  <p>Sends a robot to a specific location using RMF dynamic events.</p>
  
  <h3>Inputs</h3>
  <dl class="message-properties">
    <dt>msg.rmf_robot_name <span class="property-type">string</span></dt>
    <dd>The name of the robot to command. Overrides node configuration if provided.</dd>
    
    <dt>msg.rmf_robot_fleet <span class="property-type">string</span></dt>
    <dd>The fleet the robot belongs to. Overrides node configuration if provided.</dd>
    
    <dt>msg.location_name <span class="property-type">string</span></dt>
    <dd>The destination location name. Overrides node configuration if provided.</dd>
    
    <dt>msg.zone_type <span class="property-type">string</span></dt>
    <dd>For zone locations, the placement type (all, left, right, center, top, bottom, patient_facing, etc.).</dd>
    
    <dt>msg.zone_preferred_waypoint <span class="property-type">string</span></dt>
    <dd>For zone locations, specific waypoint name within the zone.</dd>
    
    <dt class="optional">msg.robot_name <span class="property-type">string</span></dt>
    <dd>Legacy alias for msg.rmf_robot_name.</dd>
    
    <dt class="optional">msg.robot_fleet <span class="property-type">string</span></dt>
    <dd>Legacy alias for msg.rmf_robot_fleet.</dd>
  </dl>
  
  <h3>Outputs</h3>
  <ol class="node-ports">
    <li>Success
      <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Success response from RMF system with task details.</dd>
      </dl>
    </li>
    <li>Failed
      <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Error response when goto task fails.</dd>
      </dl>
    </li>
    <li>Status
      <dl class="message-properties">
        <dt>payload <span class="property-type">object</span></dt>
        <dd>Ongoing status updates during task execution.</dd>
      </dl>
    </li>
  </ol>
  
  <h3>Details</h3>
  <p>This node sends a goto command to move a robot to a specified location. It supports both regular waypoint locations and zone locations with placement options.</p>
  
  <p><b>Zone Support:</b> When a zone is selected, additional options appear for zone type (placement) and preferred waypoint selection. Zones provide flexible positioning within defined areas.</p>
  
  <p><b>Fleet Integration:</b> The node automatically filters locations based on the selected robot fleet, ensuring only accessible locations are shown.</p>
  
  <p><b>Dynamic Configuration:</b> All parameters can be set via incoming messages, allowing for dynamic robot navigation based on runtime conditions.</p>
</script>
